---
title: 【剑指】5.2 优化时间效率
date: 2020-08-05
tags: 
 - 数组
categories:
 - 剑指Offer
---
::: tip
面试的时候要展现敏捷的思维能力和追求完美的激情，第一时间告诉面试官最直观的想法能体现出思维的敏捷，同时在寻找更优的办法的路上也不能轻言退缩，要有解决问题的态度和激情。
:::
<!-- more -->

## 面试题39：数组中出现次数超过一半的数字
### 题目描述
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。

### 解题思路
拿到题目可能直观的思路是对数组进行排序，这时出现次数超过一半的数字一定出现在中间位置，这种方法需要O(nlogn)的时间；或者使用哈希表进行计数，最后选出次数最多的，这需要使用额外的O(n)空间和O(2n)的时间。

我们可以根据数组的性质考虑这个问题，统计时使用一个计数和max变量保存当前出现最多的数字和出现次数，超过半数的数的影响最大，最终一定是超过半数的数字留到最后。
```java
public int MoreThanHalfNum_Solution(int [] array) {
    if (array==null||array.length==0) return 0;
    int count = 1, maxAppear = array[0];
    for (int i = 1; i < array.length; i++) {
        if (array[i] == maxAppear) {
            count++;
        } else if (count > 0) {
            count--;
        } else {
            count=1;
            maxAppear = array[i];
        } 
    }
    count = 0;
    for (int num : array) {
        if (num==maxAppear) count++;
    }
    return count > array.length / 2 ? maxAppear : 0;
}
```

## 面试题40：最小的K个数
### 题目描述
输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。

### 解题思路
拿到题目最直接的思路就是最输入数组进行排序，这时最前面的K个数就是最小的K个数，时间复杂度为O(nlogn)。但对于可能输入的海量数据不能全部同时加载到内存的，可以使用大小为K一个最大堆，当堆满了之后，对于每一个到达的数字，如果它大于堆顶则不可能在前K小的数中，否则删除堆顶并插入该元素。这种方法的时间复杂度为O(nlogk)。

现在可以采用类似快速排序的思想，每次进行partition，我们能确认小于枢轴的数有几个，如果枢轴大于k则继续对左半边执行partition，否则对右半边执行，知道piviot=k-1为止。该方法的时间复杂度为O(n)。
```java
public class LeastKNums {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        ArrayList<Integer> list = new ArrayList<>();
        if (input == null || k <= 0 || k > input.length) return list;
        int left = 0, right = input.length;
        while (left < right) {
            int pivot = partition(input, left, right);
            if (pivot == k-1) {
                for (int i = 0; i <= pivot; i++) {
                    list.add(input[i]);
                }
                return list;
            }
            if (pivot < k-1) {
                left = pivot + 1;
            } else {
                right = pivot;
            }
        }
        return list;
    }

    private int partition(int[] array, int left, int right) {
        int pivot = array[right - 1];
        int index = left;
        for (int i = left; i < right - 1; i++) {
            if (array[i] < pivot) {
                swap(array,index,i);
                index++;
            }
        }
        swap(array, index, right - 1);
        return index;
    }

    private void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}
```