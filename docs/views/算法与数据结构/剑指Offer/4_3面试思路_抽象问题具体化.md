---
title: 【剑指】4.3 举例具体化抽象问题
date: 2020-07-28
tags: 
 - 栈
categories:
 - 剑指Offer
---
::: tip
这一小节和上一节类似，一些不适合用图而适合直接用数据表示的题目，可以举例子具体化来找出其中的规律。
:::

<!-- more -->

## 面试题30：包含min函数的栈
### 题目描述
定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O(1)）。

### 解题思路
使用一个辅助栈来保存当前主栈中的最小值。当要入栈时，比较元素与辅助栈的栈顶，如果辅助栈为空或栈顶元素大于等于要入栈的元素则同时把元素压入辅助栈中；元素从主栈中出栈时，如果辅助栈顶元素相等则也一同出栈。
```java
import java.util.ArrayDeque;
import java.util.Deque;

public class MinStack {
    Deque<Integer> mainStack = new ArrayDeque<>();
    Deque<Integer> minStack = new ArrayDeque<>();

    public void push(int node) {
        if (minStack.isEmpty()||node<=minStack.peek()){
            minStack.push(node);
        }
        mainStack.push(node);
    }

    public void pop() {
        int node = mainStack.pop();
        if (!minStack.isEmpty() && minStack.peek() == node) {
            minStack.pop();
        }
    }

    public int top() {
        return mainStack.isEmpty() ? 0 : mainStack.peek();
    }

    public int min() {
        return minStack.isEmpty() ? Integer.MIN_VALUE : minStack.peek();
    }
}
```

## 面试题31：栈的压入、弹出序列
### 题目描述
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

### 解题思路
如果下一个要弹出的数字和栈顶数字相同，那么直接弹出，否则就继续按入栈顺序入栈直到栈顶元素和要弹出的栈顶数字相同为止。如果入栈完毕栈顶和要出栈的元素仍不相等，则不可能是一个弹出序列。
```java
    public boolean isPopOrder(int [] pushA,int [] popA) {
        if (pushA == null || popA == null || pushA.length != popA.length) return false;
        Deque<Integer> stack = new ArrayDeque<>();
        int n = pushA.length, pushIndex = 0;
        outer:
        for (int i = 0; i < n; i++) {
            //如果栈顶元素和当前要弹出的值相同则弹出，开始下一次循环
            if (!stack.isEmpty() && stack.peek() == popA[i]) {
                stack.pop();
                continue;
            }
            //否则直到找到和当前元素相同的值之前，依次将pushA中的元素入栈
            while (pushIndex < n) {
                stack.push(pushA[pushIndex++]);
                //如果发现压入的值和popA当前要弹出的值相同，就在保持i不变的情况下继续下一次外层循环
                if (pushA[pushIndex-1] == popA[i]){
                    i--;
                    continue outer;
                }
            }
            //如果pushA的元素全部入栈都没有和pop[i]相同的
            return false;
        }
        //最后的情况是所有元素都正确入栈、和popA吻合、出栈
        //由第一个continue后i==n，正常结束for循环而没有提前返回false
        return true;
    }
```