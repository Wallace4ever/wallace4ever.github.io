---
title: 【剑指】5.2 优化时间效率
date: 2020-08-05
tags: 
 - 数组
categories:
 - 剑指Offer
---
::: tip
由于内存成本的下降，现代计算机往往配有充足的内存，所以在处理通常问题时我们更愿意用空间换时间（嵌入式开发和处理海量数据等场景除外）。本节虽然说的时时空平衡，但显然更倾向于优化时间，当然和面试官探讨时空权衡的问题总是好的。
:::
<!-- more -->

## 面试题49：丑数
### 题目描述
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

### 解题思路
如果采用暴力法从1网上搜索每一个整数是否为丑数，直到找出第N个丑数，时间复杂度过大，且搜索了很多不是丑数的数。可以考虑维护一个丑数数组，从小往大，每次把得到的丑数不断乘以2、3、5之后放入他们对应的位置即可。

现在问题的难点就变为了如何将乘出来的丑数放在合适的位置。我们只需要根据当前找到的丑数中的最大值来找下一个数即可，下一个数只可能是由已找到的某数乘2或乘3或乘5得来，这样，我们只要从刚好乘以2、3、5后会大于当前最大丑数的数中比较出乘积最小的那一个放入数组中即可。使用三个指针来分别标记当前乘以2、3、5后会大于数组最大值的数。从三个数乘的结果中选出最小的放入数组并更新对应的指针，那么剩下的指针自然是会大于该数组的最大值。又由于当ugly[i]*2（或3或5）被选为下一个数组的最大值后，下一个乘2（或3或5）大于数组最大值的自然就是ugly[i+1]，更新指针时只需要加一即可。
```java
public int GetUglyNumber_Solution(int index) {
    if (index < 1) return 0;
    int[] ugly = new int[index];
    //初始化第一个丑数
    ugly[0] = 1;
    //指向乘以2、3、5后可能会大于当前最大丑数的位置
    int p2 = 0, p3 = 0, p5 = 0;
    for (int i = 1; i < index; i++) {
        ugly[i] = Math.min(ugly[p2] * 2, Math.min(ugly[p3] * 3, ugly[p5] * 5));
        if (ugly[i] == ugly[p2] * 2) p2++;
        if (ugly[i] == ugly[p3] * 3) p3++;
        if (ugly[i] == ugly[p5] * 5) p5++;
    }
    return ugly[index - 1];
}
```

## 面试题50：第一个只出现一次的字符
### 题目描述
在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）

### 解题思路
暴力法针对每一个字符都要搜索整个字符串看有没有重复字符，时间复杂度为O(n^2)。我们可以遍历一遍字符串，使用一个哈希表记录某个字符出现的次数，再次遍历就能找到首个只出现一次的字符。由于没有说明是英文字母或ASCII字符，我们只能使用库函数提供的HashMap而不好使用数组。
```java
public int FirstNotRepeatingChar(String str) {
    if(str == null || str.length() == 0) return -1;
    int n = str.length();
    HashMap<Character,Integer> map = new HashMap<>();
    for(int i = 0; i < n; i++){
        char c = str.charAt(i);
        map.put(c, map.getOrDefault(c, 0) + 1);
    }
    for(int i = 0; i < n; i++){
        if(map.get(str.charAt(i)) == 1) return i;
    }
    return -1;
}
```