---
title: 【剑指】6.3 知识迁移能力
date: 2020-08-14
tags: 
 - 数组
 - 链表
 - 哈希表
categories:
 - 剑指Offer
---
::: tip
面试中有许多隐性考察的能力，沟通和学习的能力往往是相互交织的。知识迁移的能力则是把已经掌握的知识和举一反三应用到新的场景和问题上。
:::
<!-- more -->

## 面试题53：在排序数组中查找数字
### 题目描述
统计一个数字在排序数组中出现的次数。
### 解题思路
如果采用线性搜索的方法，时间复杂度为O(n)，没有利用到数组有序的性质。该性质令人联想到二分查找，我们使用二分查找找到目标数之后，如何寻找左右可能存在相同的数的边界？如果向两侧线性查找，那么时间复杂度又会提升至O(n)。所以在二分查找时如果找到目标数不应该停下，而是应该固定一侧已知边界继续寻找另一侧边界。这里的思路可以参考之前做过的[二分查找相关的问题](../LeetCode/040_二分查找3.md)。
```java
public int GetNumberOfK(int [] array , int k) {
    if (array == null || array.length == 0) return 0;
    if (k < array[0] || k > array[array.length - 1]) return 0;
    int right = findBoundary(array, k, false);
    if (right == -1) return 0;
    return right - findBoundary(array, k, true) + 1;
}

private int findBoundary(int[] array, int target, boolean findLeft) {
    int left = 0, right = array.length - 1;
    while (left <= right) {
        int mid = left + ((right - left) >> 1);
        if (array[mid] == target) {
            if (findLeft)
                right = mid - 1;
            else
                left = mid + 1;
        } else if (array[mid] > target) {
            right = mid - 1;
        } else if (array[mid] < target) {
            left = mid + 1;
        }
    }
    if (findLeft && left < array.length && array[left] == target)
        return left;
    if (!findLeft && right >= 0 && array[right] == target)
        return right;
    return -1;
}
```

类似的二分查找知识迁移相关的问题有：
* 0~n-1这n个数中缺少了某数后排序存在长度为n-1的数组中，找出这个缺少的数字：我们知道这个数字左边的所有数本身和下标都是相同的，这个数右边的所有数和下标都是不同的，那么可以用二分查找去寻找这个数。
* 找出排序数组中数值和下标相等的元素（数组元素唯一）：如果数组中一个数的值x大于下标i，那么它右边的数最小为x+1，必定大于i+1，同理可以推到x右边的所有数的值都会大于它们的下标；同理若x小于i，则其左边所有的数的值都会小于其下标。找到相同的数返回即可，不相同则用二分查找的思想继续查找。

## 面试题54：二叉搜索树的第k小节点
### 题目描述
给定一棵二叉搜索树，请找出其中的第k小的结点。

### 解题思路
二叉搜素树的中序遍历结果就是其中元素的排序结果，所以每访问到父亲节点的内容就将计数加一，直到和k相同。
```java
public class No54_KthNodeOfBST {
    private int count = 0;
    TreeNode KthNode(TreeNode pRoot, int k) {
        if (pRoot == null || k < 1) return null;
        TreeNode answer = null;
        if (pRoot.left != null) answer = KthNode(pRoot.left, k);
        if (answer != null) return answer;
        if (++count == k) return pRoot;
        if (pRoot.right != null) answer = KthNode(pRoot.right, k);
        return answer;
    }
}
```