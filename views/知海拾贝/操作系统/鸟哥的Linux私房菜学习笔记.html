<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>鸟哥的Linux私房菜学习笔记 | Wallace&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="记录个人修行中的点滴">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.f7eaaecd.css" as="style"><link rel="preload" href="/assets/js/app.c3dada13.js" as="script"><link rel="preload" href="/assets/js/3.113ae115.js" as="script"><link rel="preload" href="/assets/js/1.24f57cb6.js" as="script"><link rel="preload" href="/assets/js/23.25640d0b.js" as="script"><link rel="prefetch" href="/assets/js/10.cea410fe.js"><link rel="prefetch" href="/assets/js/100.a7a53a73.js"><link rel="prefetch" href="/assets/js/101.5bc41419.js"><link rel="prefetch" href="/assets/js/102.015ded9b.js"><link rel="prefetch" href="/assets/js/103.f1983baf.js"><link rel="prefetch" href="/assets/js/104.5a9283bb.js"><link rel="prefetch" href="/assets/js/105.2db5299f.js"><link rel="prefetch" href="/assets/js/106.b964abdd.js"><link rel="prefetch" href="/assets/js/107.6fd0d8bc.js"><link rel="prefetch" href="/assets/js/108.2d8d2698.js"><link rel="prefetch" href="/assets/js/109.10e96e09.js"><link rel="prefetch" href="/assets/js/11.070a2bb7.js"><link rel="prefetch" href="/assets/js/110.e17c5171.js"><link rel="prefetch" href="/assets/js/111.ab01fc77.js"><link rel="prefetch" href="/assets/js/112.061d929b.js"><link rel="prefetch" href="/assets/js/113.c3352ca7.js"><link rel="prefetch" href="/assets/js/114.0b0279f8.js"><link rel="prefetch" href="/assets/js/115.89acb09d.js"><link rel="prefetch" href="/assets/js/116.30599fc5.js"><link rel="prefetch" href="/assets/js/117.6dbe04c3.js"><link rel="prefetch" href="/assets/js/118.1622a349.js"><link rel="prefetch" href="/assets/js/119.d276cb99.js"><link rel="prefetch" href="/assets/js/12.ef94bac0.js"><link rel="prefetch" href="/assets/js/120.55de9008.js"><link rel="prefetch" href="/assets/js/121.388bb202.js"><link rel="prefetch" href="/assets/js/122.5d721df9.js"><link rel="prefetch" href="/assets/js/123.6151dbd8.js"><link rel="prefetch" href="/assets/js/124.d7f670f3.js"><link rel="prefetch" href="/assets/js/125.02ce9f54.js"><link rel="prefetch" href="/assets/js/126.57bd5f57.js"><link rel="prefetch" href="/assets/js/127.2d4aa5d9.js"><link rel="prefetch" href="/assets/js/128.569b2fdc.js"><link rel="prefetch" href="/assets/js/129.89bacca9.js"><link rel="prefetch" href="/assets/js/13.23b7834b.js"><link rel="prefetch" href="/assets/js/130.cf2ec62c.js"><link rel="prefetch" href="/assets/js/131.3a2b3280.js"><link rel="prefetch" href="/assets/js/132.c01c6960.js"><link rel="prefetch" href="/assets/js/133.0472ee2a.js"><link rel="prefetch" href="/assets/js/134.480122d5.js"><link rel="prefetch" href="/assets/js/135.6104f370.js"><link rel="prefetch" href="/assets/js/136.cd9f16d8.js"><link rel="prefetch" href="/assets/js/137.2800ad31.js"><link rel="prefetch" href="/assets/js/138.ca80a594.js"><link rel="prefetch" href="/assets/js/139.f98fd758.js"><link rel="prefetch" href="/assets/js/14.bcf064a5.js"><link rel="prefetch" href="/assets/js/140.31eb4c38.js"><link rel="prefetch" href="/assets/js/141.72fb5ea8.js"><link rel="prefetch" href="/assets/js/142.476cb71d.js"><link rel="prefetch" href="/assets/js/143.65e60d09.js"><link rel="prefetch" href="/assets/js/144.c8ac8f0c.js"><link rel="prefetch" href="/assets/js/145.9ae65ef8.js"><link rel="prefetch" href="/assets/js/146.35df5536.js"><link rel="prefetch" href="/assets/js/147.fdf74a13.js"><link rel="prefetch" href="/assets/js/148.c884ca76.js"><link rel="prefetch" href="/assets/js/149.eb0586e3.js"><link rel="prefetch" href="/assets/js/15.002a59f0.js"><link rel="prefetch" href="/assets/js/150.946f12df.js"><link rel="prefetch" href="/assets/js/151.8d114df7.js"><link rel="prefetch" href="/assets/js/152.773b8485.js"><link rel="prefetch" href="/assets/js/153.268e0f46.js"><link rel="prefetch" href="/assets/js/154.54c74cf6.js"><link rel="prefetch" href="/assets/js/16.999094e9.js"><link rel="prefetch" href="/assets/js/17.52707c87.js"><link rel="prefetch" href="/assets/js/18.9108e4cd.js"><link rel="prefetch" href="/assets/js/19.56153de7.js"><link rel="prefetch" href="/assets/js/20.b95f1516.js"><link rel="prefetch" href="/assets/js/21.df0eda7c.js"><link rel="prefetch" href="/assets/js/22.11612069.js"><link rel="prefetch" href="/assets/js/24.e6cb6881.js"><link rel="prefetch" href="/assets/js/25.3db0d85c.js"><link rel="prefetch" href="/assets/js/26.1833dee9.js"><link rel="prefetch" href="/assets/js/27.5032fc20.js"><link rel="prefetch" href="/assets/js/28.6054f6a7.js"><link rel="prefetch" href="/assets/js/29.7c10cb64.js"><link rel="prefetch" href="/assets/js/30.b971fd4a.js"><link rel="prefetch" href="/assets/js/31.46a7057e.js"><link rel="prefetch" href="/assets/js/32.35464b59.js"><link rel="prefetch" href="/assets/js/33.9a683b2c.js"><link rel="prefetch" href="/assets/js/34.09fe3f0f.js"><link rel="prefetch" href="/assets/js/35.b47dab30.js"><link rel="prefetch" href="/assets/js/36.5b982f08.js"><link rel="prefetch" href="/assets/js/37.8f1854e1.js"><link rel="prefetch" href="/assets/js/38.da746968.js"><link rel="prefetch" href="/assets/js/39.71c4f3fd.js"><link rel="prefetch" href="/assets/js/4.e88e52ab.js"><link rel="prefetch" href="/assets/js/40.5309c411.js"><link rel="prefetch" href="/assets/js/41.ee8a3d2f.js"><link rel="prefetch" href="/assets/js/42.b15ba90d.js"><link rel="prefetch" href="/assets/js/43.de7bdba1.js"><link rel="prefetch" href="/assets/js/44.5d545c80.js"><link rel="prefetch" href="/assets/js/45.b6fd882d.js"><link rel="prefetch" href="/assets/js/46.d113712b.js"><link rel="prefetch" href="/assets/js/47.313846e1.js"><link rel="prefetch" href="/assets/js/48.003a18e7.js"><link rel="prefetch" href="/assets/js/49.93a910ea.js"><link rel="prefetch" href="/assets/js/5.a485daaf.js"><link rel="prefetch" href="/assets/js/50.2a8fa0b8.js"><link rel="prefetch" href="/assets/js/51.56666bdb.js"><link rel="prefetch" href="/assets/js/52.e1bcd478.js"><link rel="prefetch" href="/assets/js/53.b93b3ec3.js"><link rel="prefetch" href="/assets/js/54.cf4130c8.js"><link rel="prefetch" href="/assets/js/55.ebe28b0f.js"><link rel="prefetch" href="/assets/js/56.f8b146c6.js"><link rel="prefetch" href="/assets/js/57.a382130b.js"><link rel="prefetch" href="/assets/js/58.5734e585.js"><link rel="prefetch" href="/assets/js/59.2ab32862.js"><link rel="prefetch" href="/assets/js/6.16c6b7ad.js"><link rel="prefetch" href="/assets/js/60.d07b9ed3.js"><link rel="prefetch" href="/assets/js/61.b75d3711.js"><link rel="prefetch" href="/assets/js/62.8c34fd00.js"><link rel="prefetch" href="/assets/js/63.be2c01c2.js"><link rel="prefetch" href="/assets/js/64.e87da56f.js"><link rel="prefetch" href="/assets/js/65.9b5d5e33.js"><link rel="prefetch" href="/assets/js/66.679b738b.js"><link rel="prefetch" href="/assets/js/67.e6d68708.js"><link rel="prefetch" href="/assets/js/68.989c0cc6.js"><link rel="prefetch" href="/assets/js/69.684885c9.js"><link rel="prefetch" href="/assets/js/7.4ee72216.js"><link rel="prefetch" href="/assets/js/70.9c91952b.js"><link rel="prefetch" href="/assets/js/71.1464e07d.js"><link rel="prefetch" href="/assets/js/72.1c2c6b93.js"><link rel="prefetch" href="/assets/js/73.8a613250.js"><link rel="prefetch" href="/assets/js/74.7c465239.js"><link rel="prefetch" href="/assets/js/75.ea4cb2c2.js"><link rel="prefetch" href="/assets/js/76.e3b110f2.js"><link rel="prefetch" href="/assets/js/77.fa7a31b0.js"><link rel="prefetch" href="/assets/js/78.39f83dea.js"><link rel="prefetch" href="/assets/js/79.25d6b2fa.js"><link rel="prefetch" href="/assets/js/8.b21ea89f.js"><link rel="prefetch" href="/assets/js/80.cb9c9016.js"><link rel="prefetch" href="/assets/js/81.81de8c83.js"><link rel="prefetch" href="/assets/js/82.c71ae9f7.js"><link rel="prefetch" href="/assets/js/83.39e50c48.js"><link rel="prefetch" href="/assets/js/84.6e920779.js"><link rel="prefetch" href="/assets/js/85.3fa17da8.js"><link rel="prefetch" href="/assets/js/86.1b3cb6a9.js"><link rel="prefetch" href="/assets/js/87.36451fdb.js"><link rel="prefetch" href="/assets/js/88.37712387.js"><link rel="prefetch" href="/assets/js/89.4cef831f.js"><link rel="prefetch" href="/assets/js/9.3b886d57.js"><link rel="prefetch" href="/assets/js/90.ad070d8a.js"><link rel="prefetch" href="/assets/js/91.5131f58b.js"><link rel="prefetch" href="/assets/js/92.a5080251.js"><link rel="prefetch" href="/assets/js/93.fd9a398b.js"><link rel="prefetch" href="/assets/js/94.54449211.js"><link rel="prefetch" href="/assets/js/95.c440971a.js"><link rel="prefetch" href="/assets/js/96.55366282.js"><link rel="prefetch" href="/assets/js/97.962ba1c4.js"><link rel="prefetch" href="/assets/js/98.6e5c4b28.js"><link rel="prefetch" href="/assets/js/99.0928e57f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f7eaaecd.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-dad8a512><div data-v-dad8a512><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-dad8a512 data-v-dad8a512><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-dad8a512 data-v-dad8a512><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>Wallace's Blog</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>Wallace Xu</span>
            
          <span data-v-64685f0e>2019 - </span>
          2021
        </a></span></div></div> <div class="hide" data-v-dad8a512><header class="navbar" data-v-dad8a512><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="Wallace's Blog" class="logo"> <span class="site-name">Wallace's Blog</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/个人随笔/" class="nav-link"><i class="iconfont undefined"></i>
  个人随笔
</a></li><li class="dropdown-item"><!----> <a href="/categories/知海拾贝/" class="nav-link"><i class="iconfont undefined"></i>
  知海拾贝
</a></li><li class="dropdown-item"><!----> <a href="/categories/LeetCode/" class="nav-link"><i class="iconfont undefined"></i>
  LeetCode
</a></li><li class="dropdown-item"><!----> <a href="/categories/剑指Offer/" class="nav-link"><i class="iconfont undefined"></i>
  剑指Offer
</a></li><li class="dropdown-item"><!----> <a href="/categories/自学技术/" class="nav-link"><i class="iconfont undefined"></i>
  自学技术
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系我
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/wallace4ever" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="mailto://pkxu@seu.edu.cn" class="nav-link external"><i class="iconfont reco-mail"></i>
  邮箱
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-dad8a512></div> <aside class="sidebar" data-v-dad8a512><div class="personal-info-wrapper" data-v-ca798c94 data-v-dad8a512><img src="/avatar.png" alt="author-avatar" class="personal-img" data-v-ca798c94> <h3 class="name" data-v-ca798c94>
    Wallace Xu
  </h3> <div class="num" data-v-ca798c94><div data-v-ca798c94><h3 data-v-ca798c94>144</h3> <h6 data-v-ca798c94>文章</h6></div> <div data-v-ca798c94><h3 data-v-ca798c94>53</h3> <h6 data-v-ca798c94>标签</h6></div></div> <hr data-v-ca798c94></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/个人随笔/" class="nav-link"><i class="iconfont undefined"></i>
  个人随笔
</a></li><li class="dropdown-item"><!----> <a href="/categories/知海拾贝/" class="nav-link"><i class="iconfont undefined"></i>
  知海拾贝
</a></li><li class="dropdown-item"><!----> <a href="/categories/LeetCode/" class="nav-link"><i class="iconfont undefined"></i>
  LeetCode
</a></li><li class="dropdown-item"><!----> <a href="/categories/剑指Offer/" class="nav-link"><i class="iconfont undefined"></i>
  剑指Offer
</a></li><li class="dropdown-item"><!----> <a href="/categories/自学技术/" class="nav-link"><i class="iconfont undefined"></i>
  自学技术
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系我
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/wallace4ever" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="mailto://pkxu@seu.edu.cn" class="nav-link external"><i class="iconfont reco-mail"></i>
  邮箱
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>操作系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/views/知海拾贝/操作系统/鸟哥的Linux私房菜学习笔记.html" class="active sidebar-link">鸟哥的Linux私房菜学习笔记</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-dad8a512><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>鸟哥的Linux私房菜学习笔记</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>Wallace Xu</span>
            
          <span data-v-64685f0e>2019 - </span>
          2021
        </a></span></div></div> <div data-v-dad8a512><main class="page"><div class="page-title" style="display:none;"><h1>鸟哥的Linux私房菜学习笔记</h1> <div data-v-3b7f5bdf><i class="iconfont reco-account" data-v-3b7f5bdf><span data-v-3b7f5bdf>Wallace Xu</span></i> <i class="iconfont reco-date" data-v-3b7f5bdf><span data-v-3b7f5bdf>2020-10-24</span></i> <!----> <i class="iconfont reco-tag tags" data-v-3b7f5bdf><span class="tag-item" data-v-3b7f5bdf>操作系统</span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><div class="custom-block tip"><p>以前我很爱折腾，最早接触Linux是大一那时候在学校的开源社区，入门培训就是从头安装配置Arch Linux，后面到Deepin、Ubuntu、CentOS、Manjaro再到LFS尝试过很多Linux发行版，不过总是用到哪里学到哪里，对Linux没有一个系统的学习与理解过程。《鸟哥的Linux私房菜》这本经典的入门书籍虽然不适合用作大学教材，但强调动手实践很接地气，我们就基于这本书来系统地学习Linux的设计哲学与使用技巧。</p></div> <p>建议在虚拟机中安装一个CentOS用于实践书中的知识点。我们跳过第一部分预备知识和安装过程，从第二部分开始讲起。</p> <h1 id="第二部分-linux文件、目录与磁盘格式"><a href="#第二部分-linux文件、目录与磁盘格式" class="header-anchor">#</a> 第二部分：Linux文件、目录与磁盘格式</h1> <h2 id="第6章-linux的文件权限与目录配置"><a href="#第6章-linux的文件权限与目录配置" class="header-anchor">#</a> 第6章 Linux的文件权限与目录配置</h2> <h3 id="linux文件权限概念"><a href="#linux文件权限概念" class="header-anchor">#</a> Linux文件权限概念</h3> <p>Linux中每个文件都有很多的属性和权限，其中最重要的可能就是文件所有者的概念了。在Linux中，对于一个文件可以分别为其所有者（user）、其所有者同组的用户（group）和其他用户（others）设置文件权限。通过<code>ls</code>命令的-l选项可以<code>以长列表形式</code>详细查看当前目录下非隐藏文件的详细属性:</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>➜  ~ <span class="token function">ls</span> -l
total <span class="token number">2200</span>
-rw-r--r--. <span class="token number">1</span> root root     <span class="token number">424</span> Oct <span class="token number">20</span> <span class="token number">11</span>:12 <span class="token number">1</span>.txt
-rw-------. <span class="token number">1</span> root root    <span class="token number">2062</span> Jun <span class="token number">19</span> <span class="token number">21</span>:41 anaconda-ks.cfg
-rw-r--r--. <span class="token number">1</span> root root     <span class="token number">300</span> Sep <span class="token number">24</span> <span class="token number">22</span>:11 firewallRedis.txt
-rw-r--r--. <span class="token number">1</span> root root    <span class="token number">2110</span> Jun <span class="token number">19</span> <span class="token number">21</span>:46 initial-setup-ks.cfg
drwxr-xr-x. <span class="token number">2</span> root root       <span class="token number">6</span> Jun <span class="token number">19</span> <span class="token number">21</span>:55 perl5
drwxr-xr-x. <span class="token number">2</span> root root      <span class="token number">31</span> Oct <span class="token number">20</span> <span class="token number">15</span>:45 python
drwxrwxr-x. <span class="token number">9</span> root root    <span class="token number">4096</span> Aug  <span class="token number">9</span> <span class="token number">14</span>:34 redis-6.0.6
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">2228781</span> Jul <span class="token number">21</span> 02:32 redis-6.0.6.tar.gz
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在上面我们能看到每一个文件的权限、连接数、所有者、文件所属的用户组、文件的容量、修改日期和文件名。让我们把重点放在权限部分，该部分由十个字符加一个句号组成。</p> <p>第一个字符表明了该文件是什么类型的文件，通常我们遇到最多的是【<code>-</code>表示普通文件】和【<code>d</code>表示文件夹directory】，此外还有【<code>l</code>表示符号连接文件symbolic linkfile】、【<code>b</code>表示块特殊文件block special file，通常是磁盘等设备】、【<code>c</code>表示串行端口设备character special file，如键鼠】以及【<code>p</code>表示管道文件pipe】。</p> <p>后面九个字符每三个一组分别对应所有者、用户组和其他用户的读<code>r</code>、写<code>w</code>、执行<code>x</code>权限，如果没有相应的权限就用<code>-</code>代替。对于文件夹而言，其读权限表示能否读取文件夹中的内容，写权限表示能否创建、删除、重命名、移动目录下的文件（<strong>即使没有文件的权限</strong>），执行权限表示能否进入该目录并将其作为工作目录（即不能读取该目录下的文件）。</p> <p>文件夹权限示例：我们在所有用户都可以工作的/tmp目录下以root用户的身份创建一个文件夹、在文件夹内创建一个普通文件，再切换到普通用户并尝试访问该文件夹：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 1.root用户umask=022，新建的文件夹默认权限为755（777-022），新建文件的权限是644（666-022）</span>
➜  /tmp <span class="token function">mkdir</span> testdir
<span class="token comment"># 这时以普通用户的身份是能查看testdir下的文件列表的</span>
<span class="token punctuation">[</span>wallace@centos-vm tmp<span class="token punctuation">]</span>$ <span class="token function">ls</span> -l testdir/
总用量 <span class="token number">0</span>
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">0</span> <span class="token number">10</span>月 <span class="token number">27</span> <span class="token number">15</span>:44 testfile

<span class="token comment"># 2.切换回root用户并修改testdir的权限为744</span>
➜  /tmp <span class="token function">chmod</span> <span class="token number">744</span> testdir
<span class="token comment"># 这时由于普通用户有r权限可以查询文件夹中的文件名，但没有该文件夹的x权限就没有文件夹下的文件的访问权限</span>
<span class="token punctuation">[</span>wallace@centos-vm ~<span class="token punctuation">]</span>$ ll /tmp/testdir/
ls: 无法访问/tmp/testdir/testfile: 权限不够
总用量 <span class="token number">0</span>
-????????? ? ? ? ?            ? testfile

<span class="token comment"># 3.切换回root用户并修改testdir的权限为700</span>
➜  /tmp <span class="token function">chmod</span> <span class="token number">700</span> testdir
<span class="token comment"># 这时由于连r权限都没有了就连查询文件夹中文件的权限都没有了</span>
<span class="token punctuation">[</span>wallace@centos-vm ~<span class="token punctuation">]</span>$ ll /tmp/testdir/
ls: 无法打开目录/tmp/testdir/: 权限不够
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><div class="custom-block warning"><p>所以要开放文件夹给他人访问时通常至少要给与r和x权限，但文件夹的写权限w非常重要，一定要谨慎设置。</p></div> <h3 id="修改文件的权限相关的属性"><a href="#修改文件的权限相关的属性" class="header-anchor">#</a> 修改文件的权限相关的属性</h3> <p>我们可以分别使用<code>chown</code>、<code>chgrp</code>和<code>chmod</code>修改文件的所有者、所属的用户组和权限。这三个命令可能都需要使用超级权限执行。三个命令的使用方法很相似：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">chgrp</span> 组名 要修改的文件
<span class="token function">chown</span> 用户名 要修改的文件
<span class="token function">chown</span> 用户名:组名 要修改的文件 <span class="token comment"># 可以同时或分别修改文件的用户和用户组</span>
<span class="token function">chmod</span> 权限 要修改的文件
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>他们都可以加上-R选项来递归地设置属性，例如：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 把当前目录下所有的文件及文件夹的子文件的所有者递归地设为root</span>
<span class="token function">chown</span> -R root <span class="token builtin class-name">.</span>
<span class="token comment"># 把python目录下的所有文件及子文件权限设为仅所有者可读可写可执行，其余用户均不可读</span>
<span class="token function">chmod</span> -R <span class="token number">700</span> python
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在上面chmod使用到的属性参数是三个数字，这三个数字也分别对应着所有者、用户组、其他用户的权限。读权限=4，写权限=2，执行权限=1，则他们的和能够确定对应的用户有着哪些权限。</p> <p>此外我们也可以使用chmod的符号参数来修改属性，修改时要指明身份、设置方法与设置方法对应的权限。身份包括u(user)/g(group)/o(others)/a(all)，设置方法包括+(添加特定权限)/-(移除特定权限)/=(设置全部权限)。示例：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 设置所有者可以读写执行，其余用户可以读和执行</span>
<span class="token function">chmod</span> <span class="token assign-left variable">u</span><span class="token operator">=</span>rwx,go<span class="token operator">=</span>rx myscript.sh
<span class="token comment"># 为所有人添加写权限</span>
<span class="token function">chmod</span> a+w myscript.sh
<span class="token comment"># 去除所有人的执行权限</span>
<span class="token function">chmod</span> a-x myscript.sh
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="custom-block tip"><p>复制<code>cp</code>和移动<code>mv</code>文件会保留文件的权限属性，所以要把文件给别人则在复制或移动完之后还要记得修改相关的属性权限。</p></div> <h3 id="文件默认权限与隐藏属性"><a href="#文件默认权限与隐藏属性" class="header-anchor">#</a> 文件默认权限与隐藏属性</h3> <p><strong>umask</strong></p> <p>使用umask [-S]可以查看或修改，它指的是创建文件或目录时u/g/o要拿掉的权限，文件的默认权限是666，目录的默认权限是777。root用户的umask为022，表示对于user不拿掉任何权限，对于group和others拿掉写权限。一般身份用户的umask通常为002，即保留用户组的写入权力。</p> <p><strong>chattr</strong>和<strong>lsattr</strong></p> <p>某些文件系统（如ext2、ext3、ext4）还支持文件的隐藏属性，可以通过chattr和lsattr来修改和查看。lsattr像ls一样也具有-d、-R、-a选项。chattr的用法为<code>chattr [+-=][ASacdistu] fileOrDir</code>，重要的权限有：</p> <ul><li>a，append-only，设置该属性后文件只能增加数据不能删除也不能修改数据，例如日志文件</li> <li>i，设置后让一个文件不能被删除、改名、设置连接、写入或添加数据。</li></ul> <p>只有root用户才能设置这两个属性。</p> <h3 id="linux权限补充-rwt-rwt-rws-rws-特殊权限"><a href="#linux权限补充-rwt-rwt-rws-rws-特殊权限" class="header-anchor">#</a> linux权限补充：rwt rwT rws rwS 特殊权限</h3> <p>一个文件都有一个所有者, 表示该文件是谁创建的. 同时, 该文件还有一个组编号, 表示该文件所属的组, 一般为文件所有者所属的组.</p> <p>如果是一个可执行文件, 那么在执行时, 一般该文件只拥有调用该文件的用户具有的权限. 而setuid, setgid 可以来改变这种设置.</p> <ul><li>setuid（仅对二进制可执行文件有效）：该位是让普通用户可以以root用户的角色运行只有root帐号才能运行的程序或命令。</li> <li>setgid（对二进制程序和目录有效）: 目录被设置该位后，任何用户在此目录下创建的文件都具有和该目录所属的组相同的组。</li> <li>sticky bit（仅对目录有效）: 该位可以理解为防删除位。 一个文件是否可以被某用户删除， 主要取决于该文件所属的目录是否对该用户具有写权限。如果没有写权限，则这个目录下的所有文件都不能被删除，同时也不能添加新的文件。如果希望用户能够添加文件但同时不能删除文件，则可以对文件使用sticky bit位。设置该位后，就算用户对目录具有写权限，也不能删除该文件。</li></ul> <p>例如，用户账户相关的信息存储在/etc/passwd中，作为普通账户只能查看其中的信息，但普通用户却可以通过执行/usr/bin/passwd来修改自己的密码，实际上间接修改了/etc/passwd这个文件。其关键就在于/usr/bin/passwd的权限设置。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 本来普通用户只有读权限</span>
➜  ~ <span class="token function">ls</span> -l /etc/passwd
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">2760</span> <span class="token number">8</span>月  <span class="token number">10</span> <span class="token number">10</span>:54 /etc/passwd

➜  ~ <span class="token function">ls</span> -l /usr/bin/passwd 
-rwsr-xr-x. <span class="token number">1</span> root root <span class="token number">27856</span> <span class="token number">4</span>月   <span class="token number">1</span> <span class="token number">2020</span> /usr/bin/passwd
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>由于/usr/bin/passwd 文件已经设置了setuid 权限位（也就是-rwsr-xr-x中的s），所以普通用户能临时变成root，间接的修改/etc/passwd，以达到修改自己口令的权限。</p> <p>在Linux系统中，/tmp文件夹的权限就比较特殊，为<code>drwxrwxrwt</code>。表示其他用户可以读写执行该目录下的文件/文件夹但不能删除。对于该目录下的文件夹如testdir，如果设置了others用户对于其有写权限，则其子文件/夹可以被其他用户删除。一般新建的文件夹权限为755，这样就保证了其他用户一般不能删除别的用户创建的文件和文件夹。</p> <h4 id="修改以上特殊权限"><a href="#修改以上特殊权限" class="header-anchor">#</a> 修改以上特殊权限</h4> <p>修改以上这几个特殊的权限也是使用chmod命令，同样地可以使用数字参数或者符号参数来实现修改。</p> <ul><li>数字参数，例如原来我们有777，755，666，644等表示，现在在原有的权限之前扩展一位用于表示setuid，setgid和sticky 位。4表示setuid，2表示setgid，1表示sticky，那么上面的/usr/bin/passwd就可以表示为4755。</li> <li>字符参数，例如chmod u+s temp -- 为temp文件加上setuid标志；chmod g+s tempdir -- 为tempdir目录加上setgid标志；chmod o+t temp -- 为temp文件加上sticky标志。</li></ul> <p>那么原来的执行标志x到哪里去了呢? 系统是这样规定的, 如果本来在该位上有x, 则这些特殊标志显示为小写字母 (s, s, t). 否则, 显示为大写字母 (S, S, T)。</p> <div class="custom-block warning"><p>注意：setuid和setgid会面临风险，所以尽可能的少用</p></div> <h3 id="linux目录配置"><a href="#linux目录配置" class="header-anchor">#</a> Linux目录配置</h3> <p>通常各Linux发行版的目录配置的方式都遵循所谓的FHS（Filesystem Hierarchy Standard）即文件系统层次结构标准。FHS将Linux目录定义为两个维度共四种交互作用的形态。分别是：不变的（static）与可变的（variable）、可分享的（shareable）与不可分享的（unshareable）。</p> <ul><li>不变的：有些不随着distribution变动的文件，例如函数库、说明文件等。</li> <li>可变动的：经常改变的数据，例如登陆文件、新闻组等。</li> <li>可分享的：可以分享给其他系统挂载使用的目录</li> <li>不可分享的：自己机器上运行的设备文件、socket文件等等，不适合分享给其他主机。</li></ul> <p>FHS核心定义了根目录、/usr目录、/var三个目录下应该放置什么数据。</p> <ol><li><p>根目录/的意义与内容</p> <p>所有的目录都是由根目录衍生出来的，下面解释根目录下常用的放置内容。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 我们使用tree命令查看根目录结构，-d选项表示仅显示目录，-L后指明显示的目录深度</span>
➜  / tree -d -L <span class="token number">1</span> 
<span class="token builtin class-name">.</span>
├── bin -<span class="token operator">&gt;</span> usr/bin <span class="token comment"># 放置的是在单用户维护模式下还能够被操作的命令</span>
├── boot <span class="token comment"># 放置开机时会用到的文件，如内核、引导程序等</span>
├── dev <span class="token comment"># 所有设备都以文件的形式存在于此目录当中</span>
├── etc <span class="token comment"># 存放绝大多数系统的主要配置，一般用户可以查询但只有root权限能修改</span>
├── home <span class="token comment"># 存放所有一般用户的主文件夹</span>
├── lib -<span class="token operator">&gt;</span> usr/lib <span class="token comment"># 存放系统函数库和应用软件函数库，</span>
├── lib64 -<span class="token operator">&gt;</span> usr/lib64
├── media <span class="token comment"># 用于挂载可移除的设备如软盘光盘等</span>
├── mnt <span class="token comment"># 用于临时挂载额外的设备</span>
├── opt <span class="token comment"># optional，可以手动把第三方软件安装到这里</span>
├── proc <span class="token comment"># 虚拟文件系统，存在于内存中，存储内核、进程、设备、网络状态等</span>
├── root <span class="token comment"># 超级用户的主文件夹</span>
├── run 
├── sbin -<span class="token operator">&gt;</span> usr/sbin <span class="token comment"># 存放与开机、修复、还原等命令如fdisk、fsck、ifconfig</span>
├── srv
├── sys <span class="token comment"># 虚拟文件系统，记录内核相关的信息，如已加载的内核模块与内核检测到的设备信息</span>
├── tmp <span class="token comment"># 让用户或正在执行的程序暂时存放文件的地方，建议定期清理</span>
├── usr
└── var
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div></li> <li><p>/usr目录的意义与内容</p> <p>该目录的含义为UNIX Software Resource，存放的数据属于可分享的、不可变的。这里存放的不是用户数据而是系统软件资源。类似于Windows下C:\Windows和C:\Program files两个目录的综合体。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>➜  /usr tree -d -L <span class="token number">1</span>
<span class="token builtin class-name">.</span>
├── bin <span class="token comment"># 绝大多数用户可使用的命令，以前和/bin的区别在于是否与开机有关，实际上现在/bin链接至/usr/bin</span>
├── etc
├── games
├── include <span class="token comment"># 存放了用C/C++编写的头文件，这些Linux系统提供的文件为开发者提供了系统调用接口</span>
├── lib <span class="token comment"># /lib链接至此</span>
├── lib64 <span class="token comment"># /lib64链接至此</span>
├── libexec
├── <span class="token builtin class-name">local</span> <span class="token comment"># 系统管理员在本机自行安装下载的软件</span>
├── sbin <span class="token comment"># /sbin链接至此</span>
├── share <span class="token comment"># 存放不分硬件架构均可读取的数据（文本文件），如手册、文档等</span>
├── src <span class="token comment"># 源码</span>
└── tmp -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/var/tmp
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div></li> <li><p>/var目录的意义与内容</p> <p>该目录主要存放经常性变动的文件，包括缓存、登陆文件和某些软件运行时产生的文件等。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>➜  /var tree -d -L <span class="token number">1</span>
<span class="token builtin class-name">.</span>
├── account
├── adm
├── cache
├── crash
├── db
├── empty
├── <span class="token function">ftp</span>
├── games
├── gopher
├── kerberos
├── lib <span class="token comment"># 程序本身运行时需要用到的资源库</span>
├── <span class="token builtin class-name">local</span>
├── lock -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/run/lock <span class="token comment"># 某些一次只能被一个程序所使用的文件或设备</span>
├── log <span class="token comment"># 日志文件</span>
├── mail -<span class="token operator">&gt;</span> spool/mail
├── named
├── nis
├── opt
├── preserve
├── run -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/run
├── spool <span class="token comment"># 存放队列数据</span>
├── target
├── tmp
├── www
└── yp
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div></li></ol> <h2 id="第7章-linux文件与目录管理"><a href="#第7章-linux文件与目录管理" class="header-anchor">#</a> 第7章 Linux文件与目录管理</h2> <h3 id="目录与路径"><a href="#目录与路径" class="header-anchor">#</a> 目录与路径</h3> <p>平时我们会使用到绝对路径与相对路径。这方面其实没有太多可说的，以根目录<code>/</code>开头的就是绝对路径，其余的都是相对路径，其中有几个特殊的目录：</p> <ul><li><code>.</code>代表当前目录</li> <li><code>..</code>代表上层目录，根目录的上层目录是它自身</li> <li><code>-</code>代表上一次的工作目录，<code>cd -</code>类似于TV遥控器上的返回键</li> <li><code>~</code>代表当前用户的主文件夹</li> <li><code>~user</code>代表指定用户user的主文件夹</li></ul> <p>常见的与目录有关的命令有：</p> <ul><li>pwd：print name of working directory 打印当前工作目录 -P选项显示链接文件实际指向的目录</li> <li>mkdir：make directories 创建目录，使用-p（--parents）选项可以直接创建多层目录例如<code>mkdir -p level1/level2/level3</code>，使用-m（--mode=XXX）选项可以在创建时就指定文件夹的权限，如果同时使用这两个选项那么只有最深层的目录会设为指定的权限。</li> <li>rmdir：删除空目录，同样地使用-p选项可以删除上层的空目录。例如<code>rmdir -p /root/testdir/level1/level2</code>会从level2开始向上将空目录依次删除直到不能删除为止。</li></ul> <p>$PATH：是命令执行的搜索范围，普通用户的$PATH内容可能不包含/sbin这样的目录，但可以用过绝对路径执行下面的命令。使用<code>echo $PATH</code>来查看当前的路径，使用<code>PATH=&quot;$PATH&quot;:/dir</code>来临时把/dir加入到PATH中。为安全起见不建议把<code>.</code>加入到PATH中。</p> <h3 id="文件与目录管理"><a href="#文件与目录管理" class="header-anchor">#</a> 文件与目录管理</h3> <p>一、ls（list directory contents）命令应该是最常用的目录管理命令了，其常用的选项有：</p> <ul><li>-a，显示包括<code>.</code>和<code>..</code>在内的所有隐藏、非隐藏的文件和目录</li> <li>-A，显示所有隐藏、非隐藏的文件和目录</li> <li>-d，仅列出目录本身，而不是目录下的文件</li> <li>-f，单纯列出结果，不进行排序，会覆盖掉其它选项</li> <li>-F，加上identi<code>F</code>ier，用于醒目显示文件类型</li> <li>-h，将文件容量用human-friendly的方式显示</li> <li>-l，列表显示长数据串</li> <li>-r，排序结果反向输出（默认根据文件名排序）</li> <li>-S，按照文件的size进行排序</li> <li>-t，按照时间排序</li> <li>-R，递归列出子目录中的内容</li> <li>--full-time，显示详细时间</li> <li>--time={atime,ctime}，显示access time / 权限属性的change time，而非内容修改的时间modification time</li></ul> <p>二、cp命令除了单纯地复制文件，还可以创建连接文件，对比两个文件地新旧再予以更新，复制整个目录。cp可以用于复制单个文件或目录：<code>cp [-r] source dest</code>那么这时dest可以是目录或者新文件的绝对名称；也可以用于同时复制多个文件到某个目录下：<code>cp source1 source2 ... dest</code>那么dest只能是目标目录。</p> <p>其常用的选项有：</p> <ul><li>-i，--interactive，若文件已经存在，则交互式询问是否覆盖</li> <li>-n，默认不覆盖已经存在的文件</li> <li>-r，-R，--recursive，递归复制</li> <li>-p，preserve，复制时连同属性一起复制，用于存档</li> <li>-d，复制时仅复制连接文件，而不是文件本身</li> <li>-s，复制成一个symbolic link，软连接文件</li> <li>-l，复制成一个硬连接hard link</li> <li>-a，--archive，等同于-pdr，存档拷贝</li> <li>-u，--update，仅当目标文件比源文件更新才复制</li></ul> <p>如果不使用-p或-a选项的话，复制的文件相当于新建的相同内容的文件，但属性权限和调用cp的用户有关。权限低的普通用户即使使用-a选项也不能完整复制权限更高的用户组的权限。</p> <p>三、rm命令，由于rmdir只能用于删除空目录或递归删除多个空目录，可以使用rm来实现递归删除。选项有：</p> <ul><li>-r， 递归删除</li> <li>-f，强制删除，忽略不存在的文件</li> <li>-i，互动模式询问删除</li></ul> <p>四、其它：</p> <ul><li>mv命令，会保持权限属性移动文件，可用于单个文件的快速重命名。</li> <li>rename命令，可以使用正则表达式批量重命名文件</li> <li>basename/dirname filePath，分别可以获得文件名和目录名</li></ul> <h3 id="文件内容查阅"><a href="#文件内容查阅" class="header-anchor">#</a> 文件内容查阅</h3> <p>先简单介绍一下常用的查阅文件内容的命令：</p> <ul><li>cat：concatenate，从第一行开始完整显示文件的内容</li> <li>tac：从最后一行开始倒序按行显示文件的全部内容</li> <li>nl：number lines of files，显示的时候顺便输出行号</li> <li>more：按屏幕大小一页一页地显示内容</li> <li>less：与more相似，但可以向前翻页</li> <li>head：只看头几行</li> <li>tail：只看结尾几行</li> <li>od：octal dump files，以八（二）进制方式读取文件内容</li></ul> <p>一、cat命令的选项有</p> <ul><li>-n，--number，输出时为每一行都加上行号</li> <li>-b，--number-nonblank，输出时仅在非空行前加行号</li> <li>-v，显示非打印字符</li> <li>-E，--show-ends，将结尾的换行符用<code>$</code>显示</li> <li>-T，--show-tabs，将Tab显示为<code>^I</code></li> <li>-A，--show-all，等价于-vET</li></ul> <p>二、more命令。由于cat、tac和nl都是一口气将文件的所有内容输出到屏幕上，在内容很多时我们更希望可以一页一页地手动翻页查看。通过more查看文件内容时，可以进行以下交互式操作：</p> <ul><li>空格键，向下翻动一页</li> <li>回车键，向下翻动一行</li> <li>/pattern，向下搜索对应的模式</li> <li>:f，立即显示文件名和当前行数</li> <li>b，往回翻页</li></ul> <p>三、更强大的less命令。使用more时我们没法逐行逐页向前翻，只能按b回到开头。而less中，我们可以：</p> <ul><li>空格键，向下翻动一页</li> <li>PAGEDOWN/下箭头，向下翻动一页/一行</li> <li>PAGEUP/上箭头，向上翻动一页/一行</li> <li>/pattern，向下查询对应的模式</li> <li>?pattern，向上查询对应的模式</li> <li>n，重复前一次查询</li> <li>N，反向重复前一次查询</li></ul> <p>我们发现这和man page中的操作是一致的，实际上man就是调用了less来显示文件内容的。</p> <p>四、head与tail命令。只显示文件的前面或后面若干行，默认显示10行。示例：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># head -n [number] filename，显示文件开头指定行数的内容</span>
<span class="token comment"># tail -n [number] filename，显示文件结尾指定行数的内容</span>

<span class="token comment"># 显示文件倒数100行之前的内容</span>
<span class="token function">head</span> -n -100 <span class="token function">file</span>
<span class="token comment"># 显示文件正数100行之后的内容</span>
<span class="token function">tail</span> -n +100 <span class="token function">file</span>

<span class="token comment"># 持续检测文件末尾的内容（例如日志文件），按下Ctrl+C后才停止</span>
<span class="token function">tail</span> -f logfile

<span class="token comment"># 显示文件第11行到第20行的内容（先取前20行再取结果的后10行）</span>
<span class="token function">head</span> -n <span class="token number">20</span> <span class="token function">file</span> <span class="token operator">|</span> <span class="token function">tail</span> -n <span class="token number">10</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>五、使用od查阅非纯文本文件。这个命令可能用得不多，可以使用-t [a|c|d|f|o|x]来控制输出的格式。</p> <p>六、使用touch来创建空文件、修改文件的mtime与atime。</p> <ul><li>-a，修改access time</li> <li>-m，修改modification time</li> <li>-c，不创建新文件，仅修改已有文件的时间</li> <li>-d timestring，后接想要修改的日期，不使用-d则使用当前日期</li> <li>-t timestamp，使用自定的时间戳</li></ul> <p>七、使用<code>file</code>查看文件的类型</p> <h3 id="命令与文件位置的查询"><a href="#命令与文件位置的查询" class="header-anchor">#</a> 命令与文件位置的查询</h3> <p>通过<code>which</code>可以在$PATH中查找可执行命令的位置，-a选项可以找出所有吻合的而非最先找到的。</p> <p>Linux下有很多优异的文件查找命令，whereis和locate是利用数据库来查找数据建议优先使用，find是暴力查找全盘，功能很强大。</p> <ul><li>whereis [-bmsu] 文件名或目录名
<ul><li>-b，只寻找二进制文件</li> <li>-m，只寻找手册</li> <li>-s，只寻找源代码</li> <li>-u，查找特殊文件</li></ul></li> <li>locate [-ir] keyword，找到所有文件路径中包含keyword的文件
<ul><li>-i，忽略大小写</li> <li>-r，使用正则表达式</li> <li>使用updatedb来按照/etc/updatedb.conf的配置来手动更新mlocate数据库</li></ul></li> <li>find [PATH] [option] [action]可以在指定路径下（不指定则为当前pwd目录）按照选项进行查找。
<ul><li>与时间相关的选项，mtime/ctime/atime，以mtime为例：
<ul><li>find /var -mtime -4，在/var下查找小于等于4天内改动过的文件</li> <li>find /var -mtime 4，在/var下查找距今第4~第5天内改动过的文件</li> <li>find /var -mtime +4，在/var下查找距今大于等于5天前改动过的文件</li></ul></li> <li>与用户或用户组有关的选项
<ul><li>find /home -user wallace，-uid [uidOfWallace]，在/home目录下寻找所有属于Wallace的文件</li> <li>find /tmp -group root，-gid [gidOfRoot]，在/tmp目录下寻找所有属于root用户组的文件</li> <li>还有-nouser、-nogroup两个选项用于查找所属者或所属组在/etc/passwd和/etc/group中没有记录的文件</li></ul></li> <li>与文件权限和文件名有关的选项
<ul><li>-name FILENAME，查找指定文件名的文件，名称支持通配符如<code>find -name '*redis*'</code>查找当前目录下所有名称包含redis的文件</li> <li>-size [+-] SIZE，查找比SIZE大/小的文件</li> <li>-type TYPE，查找指定TYPE的文件，TYPE可以是一般文件f，设备文件b/c，目录d等等</li> <li>-perm MODE，查找恰好等于指定权限的文件（permission）</li> <li>-perm -MODE，查找包括了指定权限（权限可以更大）的文件</li> <li>-perm +MODE，查找包含指定权限中任一权限的文件</li></ul></li> <li>找到的结果默认是-print打印到屏幕，还可以通过指定<code>-exec</code>参数来接其他命令来处理查找到的结果。如<code>find -name '*redis*' -exec ls -l {} \;</code>，其中<code>{}</code>代表找到的内容，从<code>-exec</code>到<code>\;</code>转义封号之间的内容就是额外的命令。</li></ul></li></ul> <p>例题：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#1. 用find找出目前Linux系统中具有SUID的文件有哪些：</span>
<span class="token function">find</span> / -perm -4000 -exec <span class="token function">ls</span> -lh <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">\</span><span class="token punctuation">;</span>
<span class="token comment">#2. 找出/etc下文件大小介于50KB到60KB之间的文件，并将权限完整地列出：</span>
<span class="token function">find</span> /etc -size +50k -size -60k -exec <span class="token function">ls</span> -lh <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">\</span><span class="token punctuation">;</span> <span class="token comment"># 这里有两个条件，默认使用AND逻辑</span>
<span class="token function">find</span> /etc <span class="token punctuation">\</span><span class="token punctuation">(</span> -size +50k -and -size -60k <span class="token punctuation">\</span><span class="token punctuation">)</span> -exec <span class="token function">ls</span> -lh <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">\</span><span class="token punctuation">;</span> <span class="token comment"># -and可以简写为-a</span>
<span class="token comment">#3. 找出/etc下文件大小大于50KB且所有者不是root的文件并完整列出</span>
<span class="token function">find</span> /etc -size +50k -uid +0 -exec <span class="token function">ls</span> -lh <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">\</span><span class="token punctuation">;</span> <span class="token comment">#通过uid&gt;0来判断用户</span>
<span class="token function">find</span> /etc -size +50k <span class="token operator">!</span> -user root -exec <span class="token function">ls</span> -lh <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">\</span><span class="token punctuation">;</span> <span class="token comment">#通过！非运算来判断</span>
<span class="token comment">#4. 找出/etc下容量大于1500KB或容量等于0的文件</span>
<span class="token function">find</span> /etc <span class="token punctuation">\</span><span class="token punctuation">(</span> -size 1500k -o -size 0k <span class="token punctuation">\</span><span class="token punctuation">)</span> <span class="token comment"># -o就是-or</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="第8章-linux磁盘与文件系统管理"><a href="#第8章-linux磁盘与文件系统管理" class="header-anchor">#</a> 第8章 Linux磁盘与文件系统管理</h2> <h3 id="ext文件系统"><a href="#ext文件系统" class="header-anchor">#</a> EXT文件系统</h3> <p>一、认识EXTFS：</p> <p>在Linux中，文件数据除了文件的实际内容之外，还含有非常多的属性。文件系统通常会将这两部分数据放在磁盘的不同的块中：将权限与属性放置到inode中，将实际数据放置到data block中。此外还有一个超级块(superblock)会记录整个文件同的整体信息，包括inode与block的总量、使用量、余量等。</p> <p>Linux的EXT文件系统中每个文件有一个inode，可能有多个data block，data block的位置就存储在inode中，这种形式称为索引式文件系统，像FAT格式的文件系统并没有inode，每个文件的block的号码都记录在前一个block中，当文件写入的block分散地太厉害时，传统机械式磁盘就需要多转好几圈才能完整读取一个文件，所以才需要碎片整理。</p> <p>文件系统在一开始时就将inode与block规划好了，除非重新格式化或者使用resize2fs等命令重新更改文件系统大小。所以将所有的inode与block放置在一起会使得inode与block数量太大时不容易管理，因此ext2文件系统在格式化时会区分多个块组（block group），每个块组都有独立的inode/block/superblock系统，具体来说分为superblock、文件系统描述（group descriptor）、块对应表（block bitmap，记录使用与未使用的block）、inode bitmap（记录使用与未使用的inode）、inode table、data block。</p> <p>二、ETXFS与目录的关系：</p> <p>我们在EXT文件系统中新建一个目录时，会分配一个inode与至少一块block给该目录。inode记录了该目录相关权限属性与分配到哪块block号码，而block则是记录这个目录下的文件名与该文件名占用的inode号码数据。</p> <p>由于目录树是从根目录开始读起，因此系统通过挂载的信息可以找到挂载点的inode号码，此时就能够得到根目录的inode内容并依据inode读取根目录的block内记录的文件名数据，进而一层层读取到正确的子目录、文件。</p> <p>每个文件系统都有独立的inode、block、superblock等信息，文件系统只有链接到目录树才能被我们使用，该过程成为挂载。挂载点一定是目录，该目录为进入该文件系统的入口。</p> <p>三、日志文件系统（journaling file system）：</p> <p>由于写入inode table与data block这两个数据存放区域后还要更新superblock、inode bitmap、block bitmap等元数据，一旦出现故障就会发生数据不一致的问题。因此日志文件系统诞生了，其思想是在文件系统中规划出一个块，专门用于记录写入或修订文件时的步骤：</p> <ul><li>预备：在要写入一个文件时，现在日志记录块中记录该文件准备要写入。</li> <li>实际写入：写入文件的权限与数据并更新metadata。</li> <li>结束：在日志块中完成该文件的记录。</li></ul> <p>EXT文件系统从EXT3开始就支持日志文件系统。</p> <h3 id="文件系统的简单操作"><a href="#文件系统的简单操作" class="header-anchor">#</a> 文件系统的简单操作</h3> <p>一、df [-option] [目录或文件名]，(disk space available on the file system)列出文件系统的整体磁盘使用量。常用的选项有：</p> <ul><li>-a，列出所有文件系统，包括/proc等</li> <li>-k/-m，以KB/MB为单位显示，默认为KB</li> <li>-h，以human-readable的方式自行显示</li> <li>-T，连同分区的文件系统类型一起显示</li> <li>-i，不用硬盘容量而是以inode的数量来显示</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 范例</span>
➜  ~ <span class="token function">df</span> -hT
Filesystem              Type      Size  Used Avail Use% Mounted on
devtmpfs                devtmpfs  903M     <span class="token number">0</span>  903M   <span class="token number">0</span>% /dev
tmpfs                   tmpfs     919M     <span class="token number">0</span>  919M   <span class="token number">0</span>% /dev/shm
tmpfs                   tmpfs     919M  <span class="token number">9</span>.5M  910M   <span class="token number">2</span>% /run
tmpfs                   tmpfs     919M     <span class="token number">0</span>  919M   <span class="token number">0</span>% /sys/fs/cgroup
/dev/mapper/centos-root xfs        47G  <span class="token number">7</span>.2G   40G  <span class="token number">16</span>% /
/dev/sda1               xfs      1014M  186M  829M  <span class="token number">19</span>% /boot
tmpfs                   tmpfs     184M   40K  184M   <span class="token number">1</span>% /run/user/1000
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>二、du [-option] [文件或目录名]，(estimate file space usage)。df主要读取的是superblock的信息，而du会直接到文件系统中查找所有文件数据。常用的选项有：</p> <ul><li>-a，列出所有文件与目录容量，默认仅显示目录下的文件量</li> <li>-h，human-readable</li> <li>-s，只列出目录的总容量</li> <li>-S，统计时不算入子目录的大小</li> <li>-k/-m，同上</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 范例，检查根目录下每个目录所占用的容量</span>
➜  ~ <span class="token function">du</span> -sm /*
<span class="token number">0</span>	/bin
<span class="token number">153</span>	/boot
<span class="token number">0</span>	/dev
<span class="token number">47</span>	/etc
<span class="token number">96</span>	/home
<span class="token number">0</span>	/lib
<span class="token number">0</span>	/lib64
<span class="token number">0</span>	/media
<span class="token number">0</span>	/mnt
<span class="token number">218</span>	/opt
du: cannot access <span class="token string">'/proc/20992/task/20992/fd/3'</span><span class="token builtin class-name">:</span> No such <span class="token function">file</span> or directory
du: cannot access <span class="token string">'/proc/20992/task/20992/fdinfo/3'</span><span class="token builtin class-name">:</span> No such <span class="token function">file</span> or directory
du: cannot access <span class="token string">'/proc/20992/fd/3'</span><span class="token builtin class-name">:</span> No such <span class="token function">file</span> or directory
du: cannot access <span class="token string">'/proc/20992/fdinfo/3'</span><span class="token builtin class-name">:</span> No such <span class="token function">file</span> or directory
<span class="token number">0</span>	/proc
<span class="token number">155</span>	/root
du: cannot access <span class="token string">'/run/user/1000/gvfs'</span><span class="token builtin class-name">:</span> Permission denied
<span class="token number">10</span>	/run
<span class="token number">0</span>	/sbin
<span class="token number">0</span>	/srv
<span class="token number">0</span>	/sys
<span class="token number">1</span>	/tmp
<span class="token number">6048</span>	/usr
<span class="token number">603</span>	/var
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>三、连接文件ln</p> <p>Linux下的连接文件有两种，一种是类似Windows快捷方式功能的文件，可以让你快速连接到目标文件或目录，这种称为软连接（symbolic link）；另一种则是通过文件系统的inode连接来产生新的文件名，而不是产生新文件，这种称为硬链接（hard link）。</p> <ul><li>硬连接（又称实际连接）
<ul><li>由于想要读取某个文件必须经过目录记录的文件名来指向该文件的inode号码，所以其实文件名只与目录有关。硬连接其实就是在某个目录下新建一条文件名连接到某文件的inode号码而已。</li> <li>如果有多个硬连接连接到同一个文件的inode，那么可以将多个“文件名”删除，而文件的inode和block都是存在的，可以通过剩余的“文件名”来读取数据。使用硬连接设置连接文件时，仅仅是在若干目录的block中多写入一个关联数据而已，不会增加inode和block的数量（目录的block刚好满的情况除外）。</li> <li>硬连接不能跨文件系统，不能连接到目录（因为要连接目录下所有文件而不仅是目录本身，开销大不易管理）</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 在当前目录下建立目标文件的硬连接</span>
➜  ~ <span class="token function">ln</span> /etc/crontab <span class="token builtin class-name">.</span> 
<span class="token comment"># 比较两个目录下文件的信息，发现两个不同的文件名指向同一个inode</span>
➜  ~ ll -i /etc/crontab ./crontab         
<span class="token number">34934914</span> -rw-r--r--. <span class="token number">2</span> root root <span class="token number">451</span> Jun <span class="token number">10</span>  <span class="token number">2014</span> ./crontab
<span class="token number">34934914</span> -rw-r--r--. <span class="token number">2</span> root root <span class="token number">451</span> Jun <span class="token number">10</span>  <span class="token number">2014</span> /etc/crontab
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li>软连接（快捷方式）
<ul><li>本质就是再创建一个独立的文件，会让数据的读取指向它连接的文件的文件名。</li> <li>当源文件被删除后，通过软连接就无法打开指向的文件了。</li> <li>软连接可以跨文件系统，可以连接目录</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 删除前面创建的硬连接后原文件的连接数变为1</span>
➜  ~ <span class="token function">rm</span> <span class="token function">crontab</span>   
➜  ~ ll -i /etc/crontab          
<span class="token number">34934914</span> -rw-r--r--. <span class="token number">1</span> root root <span class="token number">451</span> Jun <span class="token number">10</span>  <span class="token number">2014</span> /etc/crontab
<span class="token comment"># 创建新的软连接</span>
➜  ~ <span class="token function">ln</span> -s /etc/crontab ./crontab2
<span class="token comment"># 注意原文件前的连接数仍为1</span>
➜  ~ ll -i /etc/crontab ./crontab2 
<span class="token number">67507563</span> lrwxrwxrwx. <span class="token number">1</span> root root  <span class="token number">12</span> Nov  <span class="token number">1</span> <span class="token number">19</span>:47 ./crontab2 -<span class="token operator">&gt;</span> /etc/crontab
<span class="token number">34934914</span> -rw-r--r--. <span class="token number">1</span> root root <span class="token number">451</span> Jun <span class="token number">10</span>  <span class="token number">2014</span> /etc/crontab
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li></ul> <div class="custom-block tip"><p>关于目录的连接数：</p> <p>在新建一个目录dir时，会产生三个文件名：<code>/parentdir/dir</code>、<code>/parentdir/dir/.</code>和<code>/parentdir/dir/..</code>，其中前两个文件名指向的就是该目录的inode，后一个文件名指向的是其父目录的inode。所以新建一个目录时，新目录的连接数为2，而上层目录的连接数会加1。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>➜  ~ ll -d /tmp                                              
drwxrwxrwt. <span class="token number">18</span> root root <span class="token number">4</span>.0K Nov  <span class="token number">1</span> <span class="token number">20</span>:05 /tmp
➜  ~ <span class="token function">mkdir</span> /tmp/testdir
➜  ~ ll -d /tmp        
drwxrwxrwt. <span class="token number">19</span> root root <span class="token number">4</span>.0K Nov  <span class="token number">1</span> <span class="token number">20</span>:22 /tmp
➜  ~ ll -d /tmp/testdir 
drwxr-xr-x. <span class="token number">2</span> root root <span class="token number">6</span> Nov  <span class="token number">1</span> <span class="token number">20</span>:22 /tmp/testdir
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></div> <h3 id="磁盘的分区、格式化检验与挂载"><a href="#磁盘的分区、格式化检验与挂载" class="header-anchor">#</a> 磁盘的分区、格式化检验与挂载</h3> <p>一、fdisk是一个功能强大的系统管理工具，可以用于删除、创建、格式化磁盘的分区。输入<code>fdisk -l</code>可以查看磁盘列表。直接执行<code>fdisk [设备文件名]</code>后我们进入到一个交互式界面，输入m并回车可以显示全部menu，包括了：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Command action
a   toggle a bootable flag
b   edit bsd disklabel
c   toggle the dos compatibility flag
d   delete a partition                      # 删除一个分区
g   create a new empty GPT partition table
G   create an IRIX (SGI) partition table
l   list known partition types
m   print this menu
n   add a new partition                     # 新增一个分区
o   create a new empty DOS partition table
p   print the partition table               # 在屏幕上打印分区表
q   quit without saving changes             # 不保存在程序内做的改动直接退出
s   create a new empty Sun disklabel
t   change a partition's system id
u   change display/entry units
v   verify the partition table
w   write table to disk and exit            # 将改动写入到硬盘后再退出程序
x   extra functionality (experts only)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>新建分区时会让我们选择分区类型、分区编号、起始sector、结束sector（可以直接指定大小，如+16G）。删除分区时只需要指定分区号。另外书中记载fdisk没办法处理大于2TB的磁盘分区，时至今日我手头没有这么大的硬盘，所以也没法验证现在是否改进了支持，可以使用parted命令来处理。</p> <p>传统MBR分区硬盘主分区+扩展分区的数量最多只支持到4个，扩展分区进一步划分为逻辑分区时，SATA硬盘最多分到15号分区，IDE硬盘最多分到63号。GPT分区硬盘则可以有很多主分区，当然个人使用时通常不会分到这么多分区。我们在使用d和n删除、新建分区并w保存新的分区表后就需要对各新分区进行格式化。</p> <p>二、使用mkfs（make file system）对新分区进行格式化。该命令其实是一个综合命令，下面在使用<code>mkfs -t ext4 ...</code>时实际上调用的是mkfs.ext4/mke2fs这个命令来进行格式化。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 这里由于我们没有指定详细的参数，使用的都是默认值</span>
➜  ~ <span class="token function">mkfs</span> -t ext4 /dev/sdb1
<span class="token function">mke2fs</span> <span class="token number">1.42</span>.9 <span class="token punctuation">(</span><span class="token number">28</span>-Dec-2013<span class="token punctuation">)</span>
Filesystem <span class="token assign-left variable">label</span><span class="token operator">=</span>
OS type: Linux
Block <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">4096</span> <span class="token punctuation">(</span>log<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
Fragment <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">4096</span> <span class="token punctuation">(</span>log<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token assign-left variable">Stride</span><span class="token operator">=</span><span class="token number">0</span> blocks, Stripe <span class="token assign-left variable">width</span><span class="token operator">=</span><span class="token number">0</span> blocks
<span class="token number">262144</span> inodes, <span class="token number">1048576</span> blocks
<span class="token number">52428</span> blocks <span class="token punctuation">(</span><span class="token number">5.00</span>%<span class="token punctuation">)</span> reserved <span class="token keyword">for</span> the super user
First data <span class="token assign-left variable">block</span><span class="token operator">=</span><span class="token number">0</span>
Maximum filesystem <span class="token assign-left variable">blocks</span><span class="token operator">=</span><span class="token number">1073741824</span>
<span class="token number">32</span> block <span class="token function">groups</span>
<span class="token number">32768</span> blocks per group, <span class="token number">32768</span> fragments per group
<span class="token number">8192</span> inodes per group
Superblock backups stored on blocks: 
	<span class="token number">32768</span>, <span class="token number">98304</span>, <span class="token number">163840</span>, <span class="token number">229376</span>, <span class="token number">294912</span>, <span class="token number">819200</span>, <span class="token number">884736</span>

Allocating group tables: <span class="token keyword">done</span>                            
Writing inode tables: <span class="token keyword">done</span>                            
Creating journal <span class="token punctuation">(</span><span class="token number">32768</span> blocks<span class="token punctuation">)</span>: <span class="token keyword">done</span>
Writing superblocks and filesystem accounting information: <span class="token keyword">done</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>mke2fs是一个有着很复杂选项与参数的命令，如果不是高级管理员的话没有特殊需求一般用得不多，了解即可。</p> <p>三、使用fsck（file system check）来检查文件系统的错乱，常用的选项有：</p> <ul><li>-t，指定文件系统，来综合确定要调用的命令，目前通常可以自动确定FS类型因而一般不需要该选项</li> <li>-A，依据/etc/fstab的内容将需要的设备扫描一次</li> <li>-a/-y，自动修复检查到有问题的扇区</li> <li>-C，使用进度条显示检验进度</li> <li>-f，ext2/3支持强制检查</li> <li>-D，优化ext2/3中的目录</li></ul> <p>注意，执行fsck时，目标分区不能挂载到系统上。仅在文件系统出问题时root才使用此命令，正常情况使用此命令可能对系统造成危害。</p> <p>四、使用mount/unmount命令挂载/卸载磁盘</p> <p>我们在挂载磁盘到目录树时首先要确定几件事</p> <ul><li>单一文件系统不应该被重复挂载在不同的挂载点中</li> <li>单一目录不应重复挂载多个文件系统</li> <li>作为挂载点的目录理论上应该是空目录（非空目录挂载新FS时原来的文件会被暂时隐藏）</li></ul> <p>直接输入mount会显示目前挂载的信息，mount命令的常用选项有：</p> <ul><li>-a，依照/etc/fstab的配置将所有未挂载的磁盘都挂载上来</li> <li>-t，指定文件系统类型，系统会分析superblock搭配已有的驱动程序去测试挂载，所以一般不需要该选项</li> <li>-L，使用卷标Label来定位磁盘并挂载，默认使用的是设备文件名挂载（/dev/sda1）</li> <li>-o，后接文件系统挂载选项(mount options)，例如ro/rw挂载为只读/读写，remount重新挂载</li> <li>-n，不写入/etc/mtab直接挂载</li> <li>--bind，将某个目录挂载到另一个目录，本质是指向同一个inode。使用场景是适配不支持软连接的软件</li></ul> <p>-o选项参数比较多，通常我们不用-o选项而是直接使用默认配置挂载磁盘，过程如下。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 将刚才格式化后的/dev/sdb1挂载</span>
➜  ~ <span class="token function">mkdir</span> /mnt/sdb1       
➜  ~ <span class="token function">mount</span> /dev/sdb1 /mnt/sdb1 
➜  ~ <span class="token function">df</span> -h 
Filesystem               Size  Used Avail Use% Mounted on
devtmpfs                 903M     <span class="token number">0</span>  903M   <span class="token number">0</span>% /dev
tmpfs                    919M     <span class="token number">0</span>  919M   <span class="token number">0</span>% /dev/shm
tmpfs                    919M  <span class="token number">9</span>.5M  910M   <span class="token number">2</span>% /run
tmpfs                    919M     <span class="token number">0</span>  919M   <span class="token number">0</span>% /sys/fs/cgroup
/dev/mapper/centos-root   47G  <span class="token number">7</span>.2G   40G  <span class="token number">16</span>% /
/dev/sda1               1014M  186M  829M  <span class="token number">19</span>% /boot
tmpfs                    184M   28K  184M   <span class="token number">1</span>% /run/user/1000
/dev/sdb1                <span class="token number">3</span>.9G   16M  <span class="token number">3</span>.6G   <span class="token number">1</span>% /mnt/sdb1 <span class="token comment"># 看到了挂载的磁盘分区</span>

<span class="token comment"># 将根目录/重新挂载</span>
➜  ~ <span class="token function">mount</span> -o remount,rw,auto /
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>umount [-option] 设备文件名或挂载点，可以卸载磁盘，选项有-f强制卸载（例如网络文件系统无法读取）、-n不更新/etc/mtab的情况下卸载。</p> <p>其他较少使用的修改磁盘参数的命令：mknod创建block或character类型的特殊设备文件、e2label设置磁盘分区卷标、tune2fs调整ext文件系统。</p> <h3 id="设置开机挂载、虚拟光驱"><a href="#设置开机挂载、虚拟光驱" class="header-anchor">#</a> 设置开机挂载、虚拟光驱</h3> <p>Linux系统挂载的一些限制：</p> <ul><li>根目录/是必须挂载的，并且是先于其他挂载点被挂载的</li> <li>其他挂载点必须为已新建的目录，可以任意指定，但需要遵守FHS的原则</li> <li>需要遵守前面提到的几点原则，不要在同一时间内重复挂载同一分区和同一挂载点</li> <li>卸载时工作目录不能在挂载点及子目录</li></ul> <p>一、开机自动挂载的配置文件是/etc/fstab，其格式内容如下：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#</span>
<span class="token comment"># /etc/fstab</span>
<span class="token comment"># Created by anaconda on Fri Jun 19 21:19:42 2020</span>
<span class="token comment">#</span>
<span class="token comment"># Accessible filesystems, by reference, are maintained under '/dev/disk'</span>
<span class="token comment"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span>
<span class="token comment">#设备文件名或Label                           #挂载点  #文件系统    #-o参数     #是否做dump备份  #是否进行fsck</span>
/dev/mapper/centos-root                     /       xfs         defaults    <span class="token number">0</span>               <span class="token number">0</span>
<span class="token assign-left variable">UUID</span><span class="token operator">=</span>fc04847f-3586-409f-9f10-0167066aa5ce   /boot   xfs         defaults    <span class="token number">0</span>               <span class="token number">0</span>
/dev/mapper/centos-swap                     swap    swap        defaults    <span class="token number">0</span>               <span class="token number">0</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>我们只需要按照格式写入需要自动挂载的磁盘分区信息即可，实际上文件系统的挂载是记录到/etc/mtab和/proc/mounts这两个文件中的。一旦fstab中的数据有误导致无法开机而进入单用户维护模式，根目录是只读的状态，这时就需要通过<code>mount -n -o remount,rw /</code>来重新挂载根目录，这样就可以进一步修改fstab了。</p> <p>二、特殊设备loop挂载（就是虚拟光驱）
loop选项能够在不刻录镜像文件的情况下读取数据。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>➜  ~ <span class="token function">mkdir</span> /mnt/centos_dvd
➜  ~ <span class="token function">mount</span> -o loop /root/centos_dvd.iso /mnt/centos_dvd <span class="token comment"># -o后接loop选项</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在某些场景下我们使用虚拟机可以用dd命令创建一个大文件，然后挂载为loop device，就可以在不改变宿主机分区的前提下作为虚拟机的分区（不过虚拟机一般有自己专用的磁盘文件格式吧比如VHD）。使用dd命令创建的大文件也可用作swap（了解，swap在目前硬件条件提高的情况下存在意义已经不大）。</p> <h2 id="第9章-文件与文件系统的压缩与打包"><a href="#第9章-文件与文件系统的压缩与打包" class="header-anchor">#</a> 第9章 文件与文件系统的压缩与打包</h2> <p>虽然对于Linux来说扩展名没有什么作用，不过为了便于方便人记忆，Linux下不同压缩程序产生的压缩文件都对应不同的扩展名：</p> <ul><li>.Z，compress程序压缩的文件（很少使用）</li> <li>.gz，gzip程序压缩的文件</li> <li>.bz2，bzip2程序压缩的文件</li> <li>.tar，tar程序打包的数据，并没有压缩过</li> <li>.tar.gz，tar程序打包的数据，经过gzip的压缩</li> <li>.tar.bz2，tar程序打包的数据，经过bzip2的压缩</li></ul> <h3 id="linux常见压缩命令"><a href="#linux常见压缩命令" class="header-anchor">#</a> Linux常见压缩命令</h3> <p>一、gzip压缩，用法为<code>gzip [-cdtv#] 文件名</code>，常用选项有：</p> <ul><li>-c，--stdout，将压缩的数据输出到屏幕上，可通过数据流重定向来处理</li> <li>-d，--decompress，解压缩的参数</li> <li>-t，--test，检验压缩文件的一致性是否有误</li> <li>-v，--verbose，可以显示文件的压缩比等信息</li> <li>-#，--fast/-1，--best/-9，#代表等级，默认等级为6</li></ul> <p>默认压缩时可以不用加任何选项，这样压缩后的文件会替换掉源文件，可以使用-c将压缩后的数据输出到标准输出流（<code>➜ /tmp gzip -c file</code>会直接输出到屏幕，乱码），可以重定向到指定的文件中（<code>➜ /tmp gzip -c file &gt; file.gz</code>会将压缩后的编码输出到新建的文件）这时就会保留源文件。</p> <p>使用zcat可以直接查看经由gzip和compress压缩后的纯文本文件。</p> <p>二、bzip2压缩，其用法和gzip几乎相同，同样具有-c/-d/-t/-v/-#的选项，此外还有-k（--keep）保留源文件，-z强制压缩等选项。bzip2能提供比gzip更优的压缩比。压缩后的文本文件可以用bzcat来直接读取。</p> <h3 id="打包命令tar"><a href="#打包命令tar" class="header-anchor">#</a> 打包命令tar</h3> <p>虽然gzip和bzip2都可以针对目录进行压缩，不过指的是将目录内的所有文件分别进行压缩。想要整体压缩则需要使用tar来打包，同时tar也可以通过gzip/bzip2的支持将打包后的文件同时压缩。</p> <p>tar的选项参数非常多，常用的参数有：</p> <ul><li>-c，--create，新建打包文件，可通过-v来查看过程中被打包的文件名</li> <li>-t，--list，查看打包文件的内容含有哪些文件名</li> <li>-x，--extract，解打包或者解压缩。（-c-t-x不可以在一条命令中同时使用）</li> <li>-C，--directory=dir，指定目标目录</li> <li>-j，--bzip2，通过bzip2进行压缩/解压缩，文件名最好为*.tar.bz2</li> <li>-z，--gzip，通过gzip进行压缩/解压缩，文件名最好为*.tar.gz</li> <li>-v，--verbose，啰嗦模式，在过程中显示信息</li> <li>-f，--file=FILE，指定要被处理的文件名</li> <li>-p，--preserve-permissions，保留数据原本的权限与属性</li> <li>-P，文件名保留绝对路径（这样的话解压后文件就会被放回到原来的位置）</li> <li>--exclude=FILE，排除某文件</li></ul> <p>简单来说，tar的使用场景主要是三种：</p> <ol><li>打包与压缩：<code>tar [-z|-j] [-cv] [-f 压缩文件名] 源文件/目录</code></li> <li>查看压缩包中的文件名列表：<code>tar [-z|-j] [-tv] [-f 压缩文件名]</code></li> <li>解压缩：<code>tar [-z|-j] [-xv] [-f 压缩文件名] [-C 要解压到的目录]</code></li></ol> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 示例：使用tar和bzip2备份/etc目录</span>
➜  /tmp <span class="token function">tar</span> -jcvp -f /root/etc.tar.bz2 /etc
tar: Removing leading `/' from member names
/etc/
/etc/fstab
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在上面的示例中，提示文件名中移除了根目录（即变成了相对路径），如果加入-P选项在文件名中保留根目录则解压时一定会按照原有的路径放置，有可能覆盖掉文件。所以一定要确定自己备份的需求再确定选项。</p> <p>仅仅提取压缩包中指定的文件：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 1. 首先使用-t选项配合grep找到想要的文件名</span>
➜  /tmp <span class="token function">tar</span> -jtv -f ~/etc.tar.bz2 <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'shadow'</span>
-rw-r--r-- root/root       <span class="token number">214</span> <span class="token number">2020</span>-08-07 01:26 etc/pam.d/sssd-shadowutils
---------- root/root       <span class="token number">883</span> <span class="token number">2020</span>-08-14 <span class="token number">10</span>:23 etc/gshadow
---------- root/root      <span class="token number">1420</span> <span class="token number">2020</span>-08-10 <span class="token number">10</span>:54 etc/shadow <span class="token comment"># 找到目标文件记录在压缩包中的文件名</span>
---------- root/root       <span class="token number">875</span> <span class="token number">2020</span>-06-19 <span class="token number">21</span>:50 etc/gshadow-
---------- root/root      <span class="token number">1420</span> <span class="token number">2020</span>-08-10 <span class="token number">10</span>:54 etc/shadow-
<span class="token comment"># 2. 指定解压压缩包中的目标文件到当前目录</span>
➜  /tmp <span class="token function">tar</span> -jxv -f ~/etc.tar.bz2 etc/shadow   <span class="token comment"># 这里我试了使用-C指定目录好像还是解压到当前目录</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>tar可以同时打包压缩多个目录并且排除特定文件，还可以利用管道命令和数据流，这些到bash部分再详细介绍。</p> <h3 id="完整备份工具dump"><a href="#完整备份工具dump" class="header-anchor">#</a> 完整备份工具dump</h3> <p>（我在CentOS7下未能找到该命令所以没法验证，应该不是dumpe2fs吧）dump除了能够针对整个文件系统进行备份，也可以仅仅针对目录进行备份。其格式为<code>dump [-Suvj] [-level] [-f 备份文件] 待备份数据</code>，进行一些简单的备份操作常用的选项有：</p> <ul><li>-S，仅列出后面待备份的数据需要多少磁盘空间才能备份完毕</li> <li>-u，将这次dump时间记录到/etc/dumpdates中</li> <li>-v，啰嗦模式</li> <li>-j，加入bzip2的支持，对数据进行压缩</li> <li>-level，指定dump等级</li> <li>-f，指定dump文件名</li> <li>-W，列出在/etc/fstab里面具有dump设置的分区是否有备份过</li></ul> <p>dump的恢复使用restore命令（同样地，我在CentOS7下没有找到该命令）就不详细介绍了。</p> <h3 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h3> <p>使用mkisofs可以将数据打包进.iso文件，再使用cdrecord可以进行光盘刻录（现在光盘已经要被淘汰了吧）。</p> <p>dd：convert and copy a file。格式为<code>dd if=INPUTFILE of=OUTPUTFILE bs=BLOCKSIZE count=NUMBER</code>，分别指明输入输出文件（可以是设备），block的大小不指名的话默认为512bytes。如果仅仅是指明文件的话看起来好像和cp命令没什么不同，但是通过指定设备文件可以实现扇区或者磁盘备份到文件，恢复的话交换if和of就可以了。由disk到disk甚至不需要经过格式化。</p> <p>cpio：copy files to and from archives。可以备份任何东西包括设备文件，不过需要结合find等能找到文件名的命令来确定要备份的数据在哪里。</p> <h1 id="第三部分-学习shell与shell-script"><a href="#第三部分-学习shell与shell-script" class="header-anchor">#</a> 第三部分 学习shell与shell script</h1> <h2 id="第10章-vim程序编辑器"><a href="#第10章-vim程序编辑器" class="header-anchor">#</a> 第10章 vim程序编辑器</h2> <p>大名鼎鼎的vim编辑器是所有UNIX Like系统都会内置的文本编辑器，学习曲线前期陡峭但学好了编辑速度能大大提升。</p> <p>vi分为三种模式：一般模式、编辑模式和命令行模式，作用分别如下：</p> <ul><li>一般模式：打开文件就进入一般模式了，在该模式中可以用方向键来移动光标，可以删除字符或整行，可以复制粘贴文件数据。</li> <li>编辑模式：在一般模式下输入<code>i/I/o/O/a/A/r/R</code>中任意一个字母后才会进入编辑模式，进入编辑模式后按ESC键就可以退回到一般模式。</li> <li>命令行模式：在一般模式中输入<code>:</code>、<code>/</code>和<code>?</code>三个字符中的任意一个就会进入命令行模式，在该模式下可以提供查找、大量替换字符等额外功能。</li></ul> <h3 id="一般模式下的常用按键说明"><a href="#一般模式下的常用按键说明" class="header-anchor">#</a> 一般模式下的常用按键说明</h3> <hr> <p>移动与定位</p> <ul><li>移动光标：使用方向键或者编辑键区的hjkl（对应←↓↑→）可以实现移动光标，想要快速移动多行的话可以用数字+方向来实现，例如要向下移动30行，可以在一般模式下输入<code>30j</code>或者<code>30↓</code>。
<ul><li>还可以通过数字+空格实现向右移动光标，数字+Enter实现向下移动光标（不过光标会到行首）</li></ul></li> <li>PageDown / Ctrl + f，forward向前翻动一页。</li> <li>PageUp / Ctrl + b，backward向后翻动一页。</li> <li>Home / 0，移动到行首</li> <li>End / $，移动到行尾</li> <li>H / M / L，移动到当前屏幕最上方/中间/下方那一行的行首</li> <li>G，移动到文件的最后一行</li> <li>nG，n为数字，移动到第n行</li> <li>gg，移动到文件的第一行，相当于1G</li></ul> <hr> <p>查找与替换</p> <ul><li>/word，向下查找名为word的字符串</li> <li>?word，向上查找名为word的字符串</li> <li>n/N，正向/反向重复上一次查找操作。这部分与less很相似。</li> <li>:num1,num2s/word1/word2/g，在num1行和num2行之间（包括num1和num2）寻找word1并替换为word2。num一般是数字，也可以是<code>$</code>表示最后一行如<code>:1,$s/line/pine/gc</code>表示从第一行到最后一行搜索line替换为pine并让用户confirm。</li></ul> <hr> <p>删除复制与粘贴</p> <ul><li>x/X，x相当于del向后删除，X向前删除。（backspace不能直接向前删除了，只是移动光标）</li> <li>nx/X，向后或向前删除n个字符</li> <li>dd，删除光标在的一整行</li> <li>ndd，向下删除包括当前行在内的n行</li> <li>d1G，删除光标所在行到第一行的所有行</li> <li>dG，删除光标所在行到最后一行的所有行</li> <li>d$，删除光标所在处到行末的所有字符</li> <li>d0，删除光标所在处到行首的所有字符</li> <li>yy，复制光标所在的行（yank）</li> <li>nyy，复制光标所在的向下n行</li> <li>y1G，复制光标所在行到第一行的数据</li> <li>yG，复制光标所在行到最后一行的所有数据</li> <li>y0，复制光标所在处到行首的所有数据</li> <li>y$，复制光标所在处到行末的所有数据</li> <li>p/P，p将已复制的数据粘贴在光标下一行，P将数据粘贴在上一行</li> <li>J，将光标所在行与下一行合并成一行</li> <li>u，复原前一个操作undo</li> <li>Ctrl + r，重做撤销的操作redo</li> <li>.，重复前一个操作</li></ul> <hr> <p>切换到编辑模式</p> <ul><li>i/I，i是在光标所在处插入insert，I是在目前行的第一个非空格字符处插入。</li> <li>a/A，进入插入模式append，a是在光标后插入，A是在行最后一个字符处插入。</li> <li>o/O，插入模式，o在下一行插入新行，O在上一行插入新行。</li> <li>r/R，进入替换模式，r只会替换光标所在字符1次，R会一直替换直到按下ESC为止。</li></ul> <hr> <p>切换到命令行模式</p> <ul><li>:w，将编辑内容写入文件</li> <li>:w!，强制写入只读文件（前提是你可以修改文件的权限）</li> <li>:q，退出vim</li> <li>:q!，丢弃修改退出vim</li> <li>:wq，写入并退出</li> <li>:wq!，强制写入并退出</li> <li>ZZ，保存后离开vim（没有冒号）</li> <li>:w FILENAME，另存一份到名为FILENAME的新文件中</li> <li>:r FILENAME，读入FILENAME的文件并将内容插入到光标所在行后面</li> <li>:n1,n2 w FILENAME，将第n1行到n2行之间的内容保存成新文件</li> <li>:! COMMAND，暂时离开vim而执行Linux命令，像ll这样的别名不能执行</li> <li>:set nu/nonu，设置vim环境显示行号/取消行号</li></ul> <p>打开文件时的警告：鸟哥提到vim通过在当前目录下创建.FILENAME.swp来暂存对文件的改动（但我按照他的方法测试后并没有发现这个隐藏文件，并且通过kill模拟意外退出再重新编辑该文件后也没有出现&quot;Found a swap file by the name ...&quot;的提示，所以这边只能看看理论）</p> <p>出现该警告一般有两种情况：1.上次由于某些原因导致vim被中断；2.可能有其他人正在编辑该文件。vim提供了一些选项：</p> <ul><li>[O]pen read-only，以只读方式打开。</li> <li>[E]dit anyway，以正常方式打开文件，并不会加载暂存文件。</li> <li>[R]ecover，加载暂存文件内容用于恢复。</li> <li>[D]elete it，删除暂存文件并继续编辑文件。</li> <li>[Q]uit，离开vim。</li> <li>[A]bort，同上。</li></ul> <h3 id="vim的功能"><a href="#vim的功能" class="header-anchor">#</a> vim的功能</h3> <p>一、块选择：前面的操作都是以行为单位的操作，如果想要实现在sublime中的鼠标中键选择一块文本的功能，可以使用块选择。</p> <ul><li>v，字符选择，会将光标经过的地方反白选择</li> <li>V，行选择，会将光标经过的行反白选择</li> <li>Ctrl + v，块选择，以光标起始点和结束点为顶点的矩形范围</li> <li>y，将反白的地方复制（yank）</li> <li>d，将反白的地方删除</li></ul> <p>二、多文件编辑：vim可以同时打开多个文件用于复制，我们在使用vim时后接多个文件来打开它们。</p> <ul><li>:n，编辑下一个文件</li> <li>:N，编辑上一个文件</li> <li>:files，列出当前vim打开的所有文件</li></ul> <p>三、多窗口功能：如果一个文件非常大，通过<code>Ctrl + f</code>和<code>Ctrl + b</code>来翻页很麻烦或者有多个文件需要比较，这时就可以通过<code>:sp</code>（split）命令来分割窗口。</p> <ul><li>:sp 或 Ctrl + w 再 s，分割窗口显示当前文件</li> <li>:sp FILENAME，分割窗口打开新文件</li> <li>Ctrl + w 再 h/j/k/l（或对应的方向键），将光标聚焦到对应方向的窗口</li> <li>Ctrl + w 再 H/J/K/L，调整光标所在窗口在显示器中的方位（类似于Windows Aero Snap）</li> <li>Ctrl + w 再 t/b/p，移动光标到左上角/右下角/上一次在的窗口</li> <li>Ctrl + w 再 q，退出关闭当前窗口</li> <li>如果配置了<code>set mouse=a</code>那么可以通过鼠标调整各窗口的边框宽窄，否则通过<code>Ctrl + w 再 &lt;/&gt;/+/-</code>可以微调水平尺寸与垂直尺寸。</li></ul> <p>四、vim配置：通过<code>:set all</code>能查看全部的vim设置，也可以直接配置~/.vimrc。这里提供一个比较舒服的配置。</p> <details class="custom-block details"><summary>See More</summary> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token string">&quot;打开语法高亮
syntax on

&quot;</span>使用配色方案
colorscheme desert

<span class="token string">&quot;打开文件类型检测功能
filetype on

&quot;</span>不同文件类型采用不同缩进
filetype indent on

<span class="token string">&quot;允许使用插件
filetype plugin on
filetype plugin indent on

&quot;</span>关闭vi模式
<span class="token builtin class-name">set</span> nocp

<span class="token string">&quot;与windows共享剪贴板
set clipboard+=unnamed

&quot;</span>取消VI兼容，VI键盘模式不易用
<span class="token builtin class-name">set</span> nocompatible

<span class="token string">&quot;显示行号, 或set number
set nu

&quot;</span>历史命令保存行数 
<span class="token builtin class-name">set</span> <span class="token assign-left variable">history</span><span class="token operator">=</span><span class="token number">100</span> 

<span class="token string">&quot;当文件被外部改变时自动读取
set autoread 

&quot;</span>取消自动备份及产生swp文件
<span class="token builtin class-name">set</span> nobackup
<span class="token builtin class-name">set</span> nowb
<span class="token builtin class-name">set</span> noswapfile

<span class="token string">&quot;允许使用鼠标点击定位
set mouse=a

&quot;</span>允许区域选择
<span class="token builtin class-name">set</span> <span class="token assign-left variable">selection</span><span class="token operator">=</span>exclusive
<span class="token builtin class-name">set</span> <span class="token assign-left variable">selectmode</span><span class="token operator">=</span>mouse,key

<span class="token string">&quot;高亮光标所在行
&quot;</span><span class="token builtin class-name">set</span> cursorline

<span class="token string">&quot;取消光标闪烁
&quot;</span><span class="token builtin class-name">set</span> novisualbell

<span class="token string">&quot;总是显示状态行
set laststatus=2

&quot;</span>状态栏显示当前执行的命令
<span class="token builtin class-name">set</span> showcmd

<span class="token string">&quot;标尺功能，显示当前光标所在行列号
set ruler

&quot;</span>设置命令行高度为3
<span class="token builtin class-name">set</span> <span class="token assign-left variable">cmdheight</span><span class="token operator">=</span><span class="token number">2</span>

<span class="token string">&quot;粘贴时保持格式
set paste

&quot;</span>高亮显示匹配的括号
<span class="token builtin class-name">set</span> showmatch

<span class="token string">&quot;在搜索的时候忽略大小写
set ignorecase

&quot;</span>高亮被搜索的句子
<span class="token builtin class-name">set</span> hlsearch

<span class="token string">&quot;在搜索时，输入的词句的逐字符高亮（类似firefox的搜索）
set incsearch

&quot;</span>继承前一行的缩进方式，特别适用于多行注释
<span class="token builtin class-name">set</span> autoindent

<span class="token string">&quot;为C程序提供自动缩进
set smartindent

&quot;</span>使用C样式的缩进
<span class="token builtin class-name">set</span> cindent

<span class="token string">&quot;制表符为4
set tabstop=4

&quot;</span>统一缩进为4
<span class="token builtin class-name">set</span> <span class="token assign-left variable">softtabstop</span><span class="token operator">=</span><span class="token number">4</span>
<span class="token builtin class-name">set</span> <span class="token assign-left variable">shiftwidth</span><span class="token operator">=</span><span class="token number">4</span>

<span class="token string">&quot;允许使用退格键，或set backspace=2
set backspace=eol,start,indent
set whichwrap+=&lt;,&gt;,h,l

&quot;</span>取消换行
<span class="token builtin class-name">set</span> nowrap

<span class="token string">&quot;启动的时候不显示那个援助索马里儿童的提示
&quot;</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">shortmess</span><span class="token operator">=</span>atI

<span class="token string">&quot;在被分割的窗口间显示空白，便于阅读
set fillchars=vert:\ ,stl:\ ,stlnc:\

&quot;</span>光标移动到buffer的顶部和底部时保持3行距离, 或set <span class="token assign-left variable">so</span><span class="token operator">=</span><span class="token number">3</span>
<span class="token builtin class-name">set</span> <span class="token assign-left variable">scrolloff</span><span class="token operator">=</span><span class="token number">3</span>

<span class="token string">&quot;设定默认解码
set fenc=utf-8
set fencs=utf-8,usc-bom,euc-jp,gb18030,gbk,gb2312,cp936

&quot;</span>设定字体
<span class="token builtin class-name">set</span> <span class="token assign-left variable">guifont</span><span class="token operator">=</span>Courier_New:h11:cANSI
<span class="token builtin class-name">set</span> <span class="token assign-left variable">guifontwide</span><span class="token operator">=</span>新宋体:h11:cGB2312

<span class="token string">&quot;设定编码，如要使用中文将下面的两行取消注释即可
set enc=utf-8
set fileencodings=ucs-bom,utf-8,chinese
&quot;</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">langmenu</span><span class="token operator">=</span>zh_CN.UTF-8
<span class="token string">&quot;language message zh_CN.UTF-8
source <span class="token variable">$VIMRUNTIME</span>/delmenu.vim
source <span class="token variable">$VIMRUNTIME</span>/menu.vim

&quot;</span>自动补全
filetype plugin indent on
<span class="token builtin class-name">set</span> <span class="token assign-left variable">completeopt</span><span class="token operator">=</span>longest,menu

&quot;自动补全命令时候使用菜单式匹配列表
<span class="token builtin class-name">set</span> wildmenu
autocmd FileType ruby,eruby <span class="token builtin class-name">set</span> <span class="token assign-left variable">omnifunc</span><span class="token operator">=</span>rubycomplete<span class="token comment">#Complete</span>
autocmd FileType python <span class="token builtin class-name">set</span> <span class="token assign-left variable">omnifunc</span><span class="token operator">=</span>pythoncomplete<span class="token comment">#Complete</span>
autocmd FileType javascript <span class="token builtin class-name">set</span> <span class="token assign-left variable">omnifunc</span><span class="token operator">=</span>javascriptcomplete<span class="token comment">#CompleteJS</span>
autocmd FileType html <span class="token builtin class-name">set</span> <span class="token assign-left variable">omnifunc</span><span class="token operator">=</span>htmlcomplete<span class="token comment">#CompleteTags</span>
autocmd FileType css <span class="token builtin class-name">set</span> <span class="token assign-left variable">omnifunc</span><span class="token operator">=</span>csscomplete<span class="token comment">#CompleteCSS</span>
autocmd FileType xml <span class="token builtin class-name">set</span> <span class="token assign-left variable">omnifunc</span><span class="token operator">=</span>xmlcomplete<span class="token comment">#CompleteTags</span>
autocmd FileType java <span class="token builtin class-name">set</span> <span class="token assign-left variable">omnifunc</span><span class="token operator">=</span>javacomplete<span class="token comment">#Complet</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br></div></div></details> <p><strong>其它注意事项</strong>
vim将用户的对于文件的编辑信息（例如搜索过的pattern、编辑位置）记录在~/.viminfo中。</p> <p>建议大家文件编码为utf-8，但某些Windows上简体中文编码默认为gb2312，可以设置机器的语系<code>LANG=zh_CN.gb2312</code>来临时解决。</p> <p>Windows和Linux/Mac的断行不同，前者采用CRLF（\r\n），而后者采用LF（\n），所以在不同操作系统间传输文件时可能需要转换。</p> <h2 id="第11章-认识与学习bash"><a href="#第11章-认识与学习bash" class="header-anchor">#</a> 第11章 认识与学习bash</h2> <p>操作系统通过内核来管理硬件，但用户不能直接操作内核，一般用户只能通过shell来和内核进行通信。我们可以在/etc/shells这个文件中查看可以使用哪些shell。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>➜  ~ <span class="token function">cat</span> /etc/shells      
/bin/sh <span class="token comment"># Bourne Shell</span>
/bin/bash <span class="token comment"># Bourne Again Shell，默认取代了Bourne Shell</span>
/bin/tcsh
/bin/csh
/bin/zsh <span class="token comment"># 基于贝尔实验室开发的ksh而来</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在/etc/passwd这个文件中记录了每个用户默认登陆后使用什么shell，下面的/sbin/nologin就是一种奇怪的shell，让用户无法以其它服务登录主机。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>➜  ~ <span class="token function">cat</span> /etc/passwd
root:x:0:0:root:/root:/bin/zsh
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Linux的默认shell是bash，高版本的MacOS将默认shell改为了zsh，我个人使用zsh并启用了oh my zsh。但通常使用上zsh和bash基本一致，只是一些体验不同。</p> <h3 id="bash的功能"><a href="#bash的功能" class="header-anchor">#</a> bash的功能</h3> <p>bash具有丰富的功能，zsh也类似：</p> <ul><li>命令历史记录，在~/.bash_history中记录了bash执行的命令历史记录，可以通过上下方向键或者history命令查看。</li> <li>命令与文件补全功能，按下tab能补全。</li> <li>命令别名设置，输入<code>alias</code>可以查看当前shell设置了哪些别名，例如<code>ll='ls -lh'</code>。也可以通过<code>alias lm='ls -la'</code>这样的命令来设置别名。</li> <li>作业控制、前台后台控制，通过该功能可以在单一登录环境中达到多任务的目的。</li> <li>程序脚本（Shell Script），可以将需要连续执行的命令写成一个脚本文件，该脚本可以通过交互式的方式来工作，也可以通过shell的环境变量来设计。</li> <li>通配符（wildcard），bash支持许多通配符来帮助用户查询执行命令。</li></ul> <p>内置命令<code>type</code>：bash提供了一些内置命令如cd、umask，我们可以使用<code>type [-tpa] COMMAND</code>命令查看某个命令的类型，常用的选项有：</p> <ul><li>-t，不加参数时，type会显示命令是外部命令还是内置命令。加上-t会显示是file（外部命令）、alias（别名）还是builtin（内置命令），（zsh下调用type不支持-t选项）。</li> <li>-p，显示外部命令包含完整path的文件名。</li> <li>-a，在PATH定义的所有路径中将所有含有COMMAND的命令都列出来。</li></ul> <p>bash内置的<code>ulimit</code>命令可以限制用户使用的某些系统资源，例如CPU时间、内存总量等。使用-a选项可以查看当前用户的限制（显示的信息中也说明了每个选项的含义）：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">ulimit</span> -a
-t: cpu <span class="token function">time</span> <span class="token punctuation">(</span>seconds<span class="token punctuation">)</span>              unlimited
-f: <span class="token function">file</span> size <span class="token punctuation">(</span>blocks<span class="token punctuation">)</span>              unlimited
-d: data seg size <span class="token punctuation">(</span>kbytes<span class="token punctuation">)</span>          unlimited
-s: stack size <span class="token punctuation">(</span>kbytes<span class="token punctuation">)</span>             <span class="token number">8192</span>
-c: core <span class="token function">file</span> size <span class="token punctuation">(</span>blocks<span class="token punctuation">)</span>         <span class="token number">0</span>
-m: resident <span class="token builtin class-name">set</span> size <span class="token punctuation">(</span>kbytes<span class="token punctuation">)</span>      unlimited
-u: processes                       <span class="token number">15024</span>
-n: <span class="token function">file</span> descriptors                <span class="token number">1024</span>
-l: locked-in-memory size <span class="token punctuation">(</span>kbytes<span class="token punctuation">)</span>  <span class="token number">64</span>
-v: address space <span class="token punctuation">(</span>kbytes<span class="token punctuation">)</span>          unlimited
-x: <span class="token function">file</span> locks                      unlimited
-i: pending signals                 <span class="token number">15024</span>
-q: bytes <span class="token keyword">in</span> POSIX msg queues       <span class="token number">819200</span>
-e: max <span class="token function">nice</span>                        <span class="token number">0</span>
-r: max rt priority                 <span class="token number">0</span>
-N <span class="token number">15</span>:                              unlimited
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>ulimit的其他选项：</p> <ul><li>-H，硬limit，必定不能超过此值</li> <li>-S，软limit，超过此值会发出警告</li> <li>-c，进程出错系统产生的core file的最大容量</li> <li>-f，此shell可产生的最大文件容量</li> <li>-d，进程可使用的最大内存分段的容量data seg size</li> <li>-l，可用于锁定的内存量</li> <li>-t，可使用的CPU时间</li> <li>-u，单用户可以使用的最大进程量</li></ul> <h3 id="shell的变量功能"><a href="#shell的变量功能" class="header-anchor">#</a> Shell的变量功能</h3> <p>变量简单来说就是用一个特定的简单字符来代表另一个比较复杂或者易变动的数据。例如，不同用户的变量<code>MAIL</code>指向不同的邮箱文件，那么不同的用户使用mail这个命令时，就会根据这个变量读取不同的邮箱文件。某些特定的变量会影响到bash的环境例如PATH、HOME、MAIL、SHELL等，为了区别与自定义变量的不同环境变量一般以大写字符表示。</p> <p>另外，在编写shell script的时候，使用自定义变量很方便。例如需要用到某个很长的路径，使用变量只需要在前面定义一次后面就不需要反复输入这个很长的路径；同时如果以后要修改也只需修改前面变量的定义，而不是反复修改脚本中的多个地方。</p> <p>一、变量定义的规则：我们可以使用<code>echo $variable</code>来查看“variable”这个变量，而设置变量则要满足一定规则：</p> <ul><li>变量名与变量内容以一个等号来连接，如<code>myName=Wallace</code>；等号两边不能有空格，像<code>my Name=Wallace</code>和<code>myName=Wallace Xu</code>这样都是错误的；变量名称只能由英文字符与数字组成，但开头不能是数字；变量内容中如果有空格可以用英文的双引号或单引号将变量内容括起来，但：
<ul><li>双引号内的特殊字符如<code>$</code>等可以保持原有特性，如设置<code>var=&quot;lang is $LANG&quot;</code>，则<code>echo $var</code>得到<code>lang is en_US.UTF-8</code>。</li> <li>单引号内的特殊字符如<code>$</code>仅为纯文本，如设置<code>var='lang is $LANG'</code>，则<code>echo $var</code>得到<code>lang is $LANG</code>。</li></ul></li> <li>可以用转义字符<code>\</code>将特殊符号如回车、dollar符、反斜线、空格、感叹号等变成一般字符。</li> <li>如果需要在设置变量时调用其他命令，可以用两个重音符将命令括起来或者用<code>$(COMMAND)</code>，例如<code>version=$(uname -r)</code>再<code>echo $version</code>可以得到<code>3.10.0-1127.19.1.el7.x86_64</code>。<div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 范例：如何进入到你当前内核的模块目录？</span>
<span class="token builtin class-name">cd</span> /lib/modules/<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -r<span class="token variable">`</span></span>/kernel <span class="token comment"># ``之间的命令的输出会作为输入</span>
<span class="token builtin class-name">cd</span> /lib/modules/<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> -r<span class="token variable">)</span></span>/kernel <span class="token comment"># 同上</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li>增加已有变量的内容可以使用<code>&quot;$变量名称&quot;</code>或<code>${变量}</code>加要累加的内容，如：<code>PATH=&quot;$PATH&quot;:/home/bin</code>。</li> <li>若该变量需要在其他子进程执行，则需要以<code>export VARIABLE</code>来使变量成为环境变量。</li></ul> <p>二、环境变量与自定义变量：使用<code>unset var</code>来取消设置变量。使用<code>env</code>可以查看当前所有的环境变量，像<code>HOME</code>、<code>SHELL</code>、<code>LANG</code>、这些都是常用的变量，值得一提的是<code>RANDOM</code>变量，目前的Linux Distribution基本上都会有随机数生成器<code>/dev/random</code>，我们可以通过该变量取得随机值，随机值在0~32767之间，要使用0~9之间的数值，利用declare声明数值类型：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">declare</span> -i <span class="token assign-left variable">number</span><span class="token operator">=</span><span class="token environment constant">$RANDOM</span>*10/32768<span class="token punctuation">;</span><span class="token builtin class-name">echo</span> <span class="token variable">$number</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>使用<code>set</code>可以查看所有的变量（包含环境变量与自定义变量）。像<code>$</code>本身也是一个变量，代表了当前shell的pid。用户在登录后拿到shell就是一个进程，在该进程下再执行bash就是前一个bash的子进程，子进程会继承父进程的环境变量，但不会继承父进程的自定义变量，所以通过<code>export</code>将变量变为环境变量就可以让该变量值继续存在于子进程中。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">echo</span> <span class="token variable">$$</span> <span class="token comment"># 查看当前shell的pid</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$?</span> <span class="token comment"># 查看上一个命令的回传码，上次成功的话回传码为0，否则非0</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>使用<code>locale</code>命令可以查看当前的语系设置，包括时间、货币、字符串格式等等，使用-a选项可以查看系统所有支持的语系。语系可以通过<code>LANG</code>这个环境变量修改。</p> <p>三、使用<code>read</code>从键盘读取变量：该命令常用在shell script中，格式为<code>read [-pt] variable</code>，将用户输入的内容读取到变量variable中。-p选项可以后接自定义的提示字符串（prompt），-t选项后接最长等待的秒数，限定时间内用户没有输入则略过。</p> <p>使用bash内置的<code>declare</code>或<code>typeset</code>命令（两者相同）可以声明变量的类型（默认为字符型）：</p> <ul><li>-a，声明后接的变量为数组类型array</li> <li>-i，声明后接的变量为整数类型integer。如<code>declare -i sum=10+20</code></li> <li>-x，export，将变量设为环境变量（+x是取消设为环境变量）</li> <li>-r，将变量设为只读，变量不可以被重设或修改</li> <li>-p，列出已经声明的某变量类型</li></ul> <p>bash环境中的数值运算只能为整形，所以1/3的结果为0。</p> <p>数组类型的变量可以通过<code>variable[n]</code>来定义和访问，n就是索引index</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>➜  ~ var<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">65</span>        
➜  ~ var<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">89</span>
➜  ~ <span class="token builtin class-name">echo</span> <span class="token variable">$var</span>   
<span class="token number">65</span> <span class="token number">89</span>
➜  ~ <span class="token builtin class-name">declare</span> -p var
<span class="token builtin class-name">typeset</span> -a var
<span class="token assign-left variable">var</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">65</span> <span class="token number">89</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>四、变量内容的部分删除与替换：</p> <p>通常访问变量的写法为<code>${variable}</code>，如果仅仅是读取内容那么我们往往将<code>echo ${variable}</code>简写成<code>echo $variable</code>，但是要在使用变量的同时作修改的话就一定要加上大括号，使用方法：</p> <p><strong>从头或者尾删除一部分字符</strong></p> <ul><li><code>${variable#start*end}</code>，警号表示从变量内容开头向后寻找到首个内容为end的部分并删除之，星号为通配符可代表任意长度的字符，start和end不可以同时省略。</li> <li><code>${variable##start*end}</code>，和上面不同之处在于##表示最长匹配，从开头向右删除能匹配的最长字符串。</li> <li><code>${variable%start*end}</code>，从右向左搜索匹配的字符串并删除，最短匹配。</li> <li><code>${variable%%start*end}</code>，从右向左删除，最长匹配。</li></ul> <p><strong>替换指定字符串</strong></p> <ul><li><code>${variable/oldStr/newStr}</code>，将从左到右首次出现的oldStr替换为newStr。</li> <li><code>${variable//oldStr/newStr}</code>，将出现的所有oldStr替换为newStr。</li></ul> <p><strong>根据旧值是否存在进一步设置新值</strong></p> <ul><li><code>${oldVariable-newContent}</code>，如果variable存在则结果是variable的内容，否则就是newContent。可以将结果赋给newVariable，也可以赋给oldVariable（其实就是有就使用没有则默认设为newContent）。</li> <li><code>variable=${variable:-newContent}</code>，如果变量内容为空或未设置都会被赋以新的内容。</li> <li><code>variable=${variable+newContent}</code>，除了变量未被设置时外都将newContent赋给结果。</li> <li><code>variable=${variable:+newContent}</code>，变量已设置且不为空时才将newContent赋给结果。</li> <li>此外还有=、:=、?、:?暂时先略过。</li></ul> <h3 id="命令别名与历史命令"><a href="#命令别名与历史命令" class="header-anchor">#</a> 命令别名与历史命令</h3> <p>一、别名alias：前面我们提到过常用的<code>ll</code>其实就是<code>ls -lh</code>的别名，在bash中可以使用<code>alias customName='COMMAND [-options]'</code>来设置别名，使用<code>unalias customName</code>可以取消别名，直接输入alias可以查看目前已经设置了那些别名。</p> <p>二、历史命令history：使用history可以查看bash的历史记录（存储在~/.bash_history中），常用的参数和选项有：</p> <ul><li>n，列出最近的n条记录（在zsh下总是显示全部历史记录，bash中正常）</li> <li>-c，清除目前shell的全部历史记录</li> <li>-a，将目前新增的命令历史追加写入到histfiles中，未指定则默认写入.bash_history</li> <li>-r，将histfiles的内容读到目前shell的history记忆中</li> <li>-w，立刻将目前的历史记录写入到histfiles中（默认是注销时写入）</li></ul> <p>历史记录不仅可以用来查询，也可以用来帮助执行命令。</p> <ul><li>!n，执行记录中的第n条命令</li> <li>!!，执行上一条命令，例如执行命令并发现需要root权限可以使用<code>sudo !!</code></li> <li>!COMMAND，执行最近的以COMMAND开头的命令，COMMAND可以不用写完整</li></ul> <p>注意如果同一个用户通过多个bash登录，最后一个注销的bash会覆盖掉前面的bash写入的会话内历史记录。</p> <h3 id="bash-shell的操作环境"><a href="#bash-shell的操作环境" class="header-anchor">#</a> Bash Shell的操作环境</h3> <p>一、执行命令的顺序：bash确定执行命令的位置的顺序是：相对绝对路径&gt;别名&gt;内置命令&gt;$PATH中第一个找到的命令。</p> <p>二、bash的登录与欢迎信息：在/etc/issue中记录了登录系统前看到的欢迎信息，默认内容是：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>➜  ~ <span class="token function">cat</span> /etc/issue <span class="token comment"># 查看内容</span>
<span class="token punctuation">\</span>S
Kernel <span class="token punctuation">\</span>r on an <span class="token punctuation">\</span>m

<span class="token comment"># 登录前看到的欢迎信息</span>
Cent0S Linux <span class="token number">7</span> <span class="token punctuation">(</span>Core<span class="token punctuation">)</span>
Kernel <span class="token number">3.16</span>.B-1127.19.1.e17.x86_64 on an x86_64
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>内容中的转义字符含义如下：</p> <ul><li>\d，本地端的日期</li> <li>\t，本地端的时间</li> <li>\l，显示是第几个终端机接口</li> <li>\m，显示硬件等级</li> <li>\n，显示主机的网络名称</li> <li>\o，显示domain name</li> <li>\r，显示操作系统的release版本</li> <li>\S，操作系统的名称</li> <li>\v，操作系统的版本</li></ul> <p>还可以编辑/etc/motd来在用户登录后显示提示信息。</p> <p>三、bash的环境配置文件：因为配置文件的存在我们进入bash的时候不用每次都进行环境的配置。首先我们需要了解login shell和non-login shell的区别，关键在于有没有进行完整的登录流程（例如按CtrlAltF2在tty登录需要输入账号密码是login shell，而在X Window登录后打开的终端不需要输入账号密码是non-login shell，在bash中再执行bash也是non-login）。</p> <p>login shell读取的配置有<code>/etc/profile</code>和<code>~/.bash_profile或~/.bash_login或~/.profile</code>。前者是系统整体的配置，可以利用UID来确定很多的变量数据例如PATH、USER、MAIL等，还会依次调用/etc/inputrc、/etc/profile.d/*.sh等配置；后者是用户个人配置，bash只会按顺序读取存在的第一个文件。修改完配置文件后一般要重新login才能应用修改，不过也可以使用<code>source ~/.profile</code>或<code>. ~/.profile</code>来立刻读入配置。non-login shell 会读取<code>~/.bashrc</code>。不过zsh配置似乎没有这么多。</p> <p>此外，还可以用<code>stty</code>和<code>set</code>来对终端机进行设置（一般不用自行修改），<code>stty -a</code>和<code>echo $-</code>查看stty和set的所有配置。</p> <p>四、通配符与特殊符号：常用的通配符有：</p> <ul><li><code>*</code>，代表0到任意多个字符</li> <li><code>?</code>，代表一定有一个任意字符</li> <li><code>[]</code>，代表一定有一个在中括号内的字符</li> <li><code>[ - ]</code>，代表在减号两侧字符编码顺序内的所有字符，如[0-9]</li> <li><code>[^ ]</code>，代表非括号内的任意字符</li></ul> <h3 id="数据流重定向"><a href="#数据流重定向" class="header-anchor">#</a> 数据流重定向</h3> <p>一、什么是数据流重定向</p> <p>Linux下标准输入stdin的代码为0，使用<code>&lt;</code>或<code>&lt;&lt;</code>；标准输出stdout的代码为1，使用<code>&gt;</code>或<code>&gt;&gt;</code>（覆盖或追加）；标准错误输出stderr的代码为2，使用<code>2&gt;</code>或<code>2&gt;&gt;</code>。</p> <p>stdout与stderror：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 假设我们是普通用户wallace要在/home目录下搜索文件myFile</span>
<span class="token comment"># 由于不具有其他用户主目录的访问权限所以我们会得到一些错误信息</span>
<span class="token comment"># 默认情况下stdout和stderr都是屏幕，现在我们将二者重定向到两个文件中</span>
<span class="token function">find</span> /home -name myFile <span class="token operator">&gt;</span> ~/list_right <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> list_error

<span class="token comment"># /dev/null是一个垃圾桶黑洞设备，会将所有导向这个设备的信息吃掉，可以用于忽略错误信息。</span>
<span class="token function">find</span> /home -name myFile <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> /dev/null <span class="token comment"># 只有正确信息会显示到屏幕上</span>

<span class="token comment"># 如果要将正确和错误信息同时写入到一个文件中可以使用&amp;&gt;或者2&gt;&amp;1</span>
<span class="token function">find</span> /home -name myFile <span class="token operator">&amp;&gt;</span> list
<span class="token function">find</span> /home -name myFile <span class="token operator">&gt;</span> list <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>stdin：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># &lt;代表将原本需要键盘输入的数据用文件内容来替代</span>
<span class="token function">cat</span> <span class="token operator">&gt;</span> catfile <span class="token operator">&lt;</span> ~/.bashrc <span class="token comment"># 输入为.bashrc，cat的结果不会输出到屏幕而是catfile</span>

<span class="token comment"># &lt;&lt;代表指定结束输入的关键字</span>
<span class="token function">cat</span> <span class="token operator">&gt;</span> catfile <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;eof&quot;</span> <span class="token comment"># 接下来在键盘输入内容，输入eof就结束输入而不需要按下ctrl+d，有助于编写程序</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>二、命令执行的判断依据; , &amp;&amp; ||</p> <p>在某些情况下我们想一次执行多条命令，这时我们可以使用shell script或者使用下面的符号来控制：</p> <ul><li><code>COMMAND1;COMMAND2</code>，这个在前面也提到过，用分号分隔两条命令，不考虑命令的相关性依次执行。</li> <li><code>COMMAND1 &amp;&amp; COMMAND2</code>，COMMAND1成功执行（True，回传码$? == 0）则执行COMMAND2，COMMAND1执行错误（False，回传码不等于0）则不执行COMMAND2。</li> <li><code>COMMAND1 || COMMAND2</code>，COMMAND1成功执行则无需执行COMMAND2，COMMAND1执行错误才执行COMMAND2。上面这两条类似于编程语言中的短路机制。</li></ul> <p>示例1：不清楚/tmp/abc目录是否存在，但是最终一定要创建/tmp/abc/test这个文件</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">ls</span> /tmp/abc <span class="token operator">||</span> <span class="token function">mkdir</span> /tmp/abc <span class="token operator">&amp;&amp;</span> <span class="token function">touch</span> /tmp/abc/test
<span class="token comment"># 如果该目录存在即（真||？）第二条命令不执行，真值继续向后传递（真&amp;&amp;？）第三条命令需要执行</span>
<span class="token comment"># 如果该目录不存在即（假||？）第二条命令执行，执行成功回传真（真&amp;&amp;？）第三条命令需要执行</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>示例2：要使得COMMAND1执行成功时则执行COMMAND2，否则执行COMMAND3。通常COMMAND2和COMMAND3都一定能执行成功。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>COMMAND1 <span class="token operator">&amp;&amp;</span> COMMAND2 <span class="token operator">||</span> COMMAND3 <span class="token comment"># 顺序不能错</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="管道命令"><a href="#管道命令" class="header-anchor">#</a> 管道命令</h3> <p>管道符号<code>|</code>仅能够将前面的命令传来的正确信息（stdout）用作后一个命令的输入。每个管道后面接的第一个数据必定是命令，并且该命令必须要能够加收stdin的数据才行（例如less、more、head、tail），而cp、ls、mv这些命令并不会接受stdin的数据。</p> <p>一、选取命令：cut、grep</p> <p>cut命令可以将同一行里面的数据进行分解，<code>-d</code>选项指定divider（默认为Tab），<code>-f</code>选项指定要取的第几个field，例如看起来可能让人觉得眼花缭乱的$PATH：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 取出由冒号分割的第三段和第五段</span>
➜  ~ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span> <span class="token operator">|</span> <span class="token function">cut</span> -d <span class="token string">':'</span> -f <span class="token number">3,5</span> 
/usr/local/rvm/rubies/ruby-2.7.0/bin:/root/perl5/bin
➜  ~ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span> <span class="token operator">|</span> <span class="token function">cut</span> -d <span class="token string">':'</span> -f <span class="token number">3</span>  
/usr/local/rvm/rubies/ruby-2.7.0/bin
➜  ~ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span> <span class="token operator">|</span> <span class="token function">cut</span> -d <span class="token string">':'</span> -f <span class="token number">5</span>
/root/perl5/bin

<span class="token comment"># 取得export命令输出的信息每行第12个字符后的所有字符串</span>
<span class="token builtin class-name">export</span> <span class="token operator">|</span> <span class="token function">cut</span> -c <span class="token number">12</span>- <span class="token comment"># -c选项表示以Character为单位取出固定字符区间，如12-20 或 12- 或 -20</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>grep的作用是分析一行的信息，若当中有我们所需要的信息就将该行拿出来。其语法为<code>grep [-acinv] [--color=auto] '查找字符串' inputFileName</code>，grep可以单独使用，如果放在管道符后使用就不需要输入文件名了，也支持使用正则表达式进行搜索。各选项的含义为：</p> <ul><li>-a，将二进制文件当作文本文件来查找数据</li> <li>-c，--count，计算找到'查找字符串'的次数</li> <li>-i，--ignore-case，忽略大小写的不同</li> <li>-n，顺便输出行号</li> <li>-v，--invert-match，反向选择没有查找字符串的行</li> <li>--color=auto，将找到的关键字加上颜色显示</li></ul> <p>二、排序命令：sort、wc、uniq</p> <p><code>sort</code>这个命令可以依据不同的数据类型来对行进行排序。用法为<code>sort [-fbMnrtuk] [file or stdin]</code>，常用的选项有：</p> <ul><li>-f，--ignore-case，忽略大小写的差异</li> <li>-b，--ignore-leading-blanks，忽略最前面的空格部分</li> <li>-M，以月份的名字（<code>(unkoown)&lt;JAN&lt;...&lt;DEC</code>）来排序</li> <li>-n，使用纯数字进行排序（默认使用字典序进行排序）</li> <li>-r，--reverse，反向排序</li> <li>-u，--unique，相同数据中仅出现一行代表</li> <li>-t，--field-separator=SEP，使用指定分隔符（默认为Tab）</li> <li>-k，--key=KEYDEF，以哪个区间为key来进行排序</li></ul> <p>示例：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 将/etc/passwd的内容取出并按照冒号分隔的第三列进行排序</span>
➜  ~ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sort</span> -t <span class="token string">':'</span> -k <span class="token number">3</span> <span class="token comment"># 默认按照字典序排序，如果需要按照数字排序需要加上-n</span>
root:x:0:0:root:/root:/bin/zsh
wallace:x:1000:1000:wallace:/home/wallace:/bin/bash
qemu:x:107:107:qemu user:/:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin

<span class="token comment"># 将last命令得到的登录历史的第一列（帐号）取出并加以排序</span>
➜  ~ last <span class="token operator">|</span> <span class="token function">cut</span> -d <span class="token string">' '</span> -f <span class="token number">1</span> <span class="token operator">|</span> <span class="token function">sort</span>  

<span class="token function">reboot</span>
<span class="token function">reboot</span>
root
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>如果排序完成了想要将重复的数据仅列出一行显示，可以使用<code>uniq</code>命令，注意要在排序后使用uniq否则只会统计相邻且相同的行的出现次数。使用-i选项可以忽略大小写的不同、使用-c选项可以统计相同行出现的次数，示例：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 想要根据用户、登录终端类型和用户地址的不同排序并统计次数，而不用管后面的登录时间</span>
➜  ~ last <span class="token operator">|</span> <span class="token function">cut</span> -c -38 <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c
      <span class="token number">1</span> 
     <span class="token number">13</span> <span class="token function">reboot</span>   system boot  <span class="token number">3.10</span>.0-1127.10.1
     <span class="token number">21</span> <span class="token function">reboot</span>   system boot  <span class="token number">3.10</span>.0-1127.19.1
      <span class="token number">3</span> <span class="token function">reboot</span>   system boot  <span class="token number">3.10</span>.0-1127.el7.
      <span class="token number">1</span> root     :0           :0              
      <span class="token number">1</span> root     pts/0        :0              
      <span class="token number">1</span> root     pts/0        <span class="token number">192.168</span>.0.8     
     <span class="token number">14</span> root     pts/0        gateway         
      <span class="token number">1</span> root     pts/1        <span class="token number">192.168</span>.0.8     
      <span class="token number">7</span> root     pts/1        gateway         
      <span class="token number">5</span> root     pts/2        gateway         
      <span class="token number">3</span> root     pts/3        gateway         
      <span class="token number">3</span> root     pts/4        gateway         
      <span class="token number">3</span> root     pts/5        gateway         
      <span class="token number">3</span> root     pts/6        gateway         
      <span class="token number">3</span> root     pts/7        gateway         
      <span class="token number">3</span> root     pts/8        gateway         
      <span class="token number">3</span> root     pts/9        gateway         
      <span class="token number">3</span> root     tty2                         
     <span class="token number">27</span> wallace  :0           :0              
     <span class="token number">31</span> wallace  pts/0        :0              
      <span class="token number">7</span> wallace  pts/1        :0              
      <span class="token number">1</span> wallace  pts/1        gateway         
      <span class="token number">1</span> wallace  pts/2        :0              
      <span class="token number">1</span> wallace  tty2                         
      <span class="token number">1</span> wtmp begins Fri Jun <span class="token number">19</span> <span class="token number">21</span>:45:32 <span class="token number">2020</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>使用<code>wc</code>（word counts）命令可以统计输入数据中有多少行、多少词、多少字符，默认输出三个数字代表前者。常用选项有：</p> <ul><li>-l，--lines，仅显示行数</li> <li>-w，--words，仅显示单词数</li> <li>-m，--chars，仅显示字符数</li> <li>-c，--bytes，仅显示字节数</li></ul> <p>示例：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 在上面的例子中，last的输出中有一个空行，同时有一个非正常帐号wtmp，现在需要统计记录总共的登录人次</span>
➜  ~ last <span class="token operator">|</span> <span class="token function">cut</span> -d <span class="token string">' '</span> -f <span class="token number">1</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'[a-zA-Z]'</span> <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token string">'wtmp'</span> <span class="token operator">|</span> <span class="token function">wc</span> -l
<span class="token number">159</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>三、双向流重定向<code>tee</code>：该命令可以从stdin中读入数据，并在原封不动的输出到stdout的同时将数据输出到指定文件中，可以用作记录中间暂存数据。选项有-a（--append）追加到文件中，-i（--ignore-interrupts）忽略中断信号。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 将last的结果存一份到文件last.list中再交由cut处理后输出到屏幕</span>
last <span class="token operator">|</span> <span class="token function">tee</span> -a last.list <span class="token operator">|</span> <span class="token function">cut</span> -d <span class="token string">''</span> -f <span class="token number">1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>四、字符转换命令tr、col、join、paste、expand</p> <p><code>tr</code>：translate or delete characters，可以用来删除一段信息中的文字，或者进行文字信息的转换。用法为<code>tr [-ds] 字符集1 ...</code>，字符集就是正则表达式中的字符集格式。示例：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 将last输出的信息中所有小写字符转换为大写字符</span>
➜  ~ last <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">'[a-z]'</span> <span class="token string">'[A-Z]'</span>

<span class="token comment"># 将读取$PATH输出的信息中的冒号删除</span>
➜  ~ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span> <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">':'</span>      
/usr/local/rvm/gems/ruby-2.7.0/bin/usr/local/rvm/gems/ruby-2.7.0@global/bin/usr/local/rvm/rubies/ruby-2.7.0/bin/usr/lib64/qt-3.3/bin/root/perl5/bin/usr/local/sbin/usr/local/bin/sbin/bin/usr/sbin/usr/bin/root/bin/usr/local/rvm/bin

<span class="token comment"># 将/etc/passwd转存到/root/passwddos文件中并将line separator改为DOS风格（CRLF）</span>
➜  ~ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">'<span class="token entity" title="\n">\n</span>'</span> <span class="token string">'<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>'</span> <span class="token operator">&gt;</span> /root/passwddos 
➜  ~ <span class="token function">file</span> /etc/passwd ./passwddos 
/etc/passwd: ASCII text
./passwddos: ASCII text, with CR line terminators
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><code>col</code>：可用于简单处理Tab和空格之间的转换（但我个人感觉<code>tr '\t' ' '</code>也能做到并且更好记一点）。</p> <p><code>join</code>：join可以将两个文件当中有相同数据的行合并到一起，参数有：</p> <ul><li>-t，和sort一样，指定分隔符</li> <li>-i，忽略大小写区别</li> <li>-1 n，第一个文件用第n个字段作为key</li> <li>-2 n，第二个文件用第n个字段作为key</li></ul> <p>在我个人看来更像是类似于按照数据库的key进行连表操作（数据库中表的连接也称为join），假如我们要处理两个文件：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 两个文件分别以uid为主键记录了一些指标</span>
➜  ~ <span class="token function">cat</span> file1                         
id1:wallace:male
id2:tony:male
id5:kale:male
➜  ~ <span class="token function">cat</span> file2
id1:16:20KG
id1:17:21KG
id3:18:21KG
id4:23:17KG
id5:24:33KG

<span class="token comment"># 现在要以两个文件的第一列为key连接两个文件</span>
➜  ~ <span class="token function">join</span> -t <span class="token string">':'</span> file1 file2 <span class="token comment"># 默认以第一个字段为key</span>
id1:wallace:male:16:20KG
id1:wallace:male:17:21KG
id5:kale:male:24:33KG

<span class="token comment"># 分别指定两个文件的key</span>
➜  ~ <span class="token function">join</span> -t <span class="token string">':'</span> -1 <span class="token number">4</span> /etc/passwd -2 <span class="token number">3</span> /etc/group
<span class="token number">0</span>:root:x:0:root:/root:/bin/zsh:root:x:
<span class="token number">1</span>:bin:x:1:bin:/bin:/sbin/nologin:bin:x:
<span class="token number">2</span>:daemon:x:2:daemon:/sbin:/sbin/nologin:daemon:x:
<span class="token number">4</span>:adm:x:3:adm:/var/adm:/sbin/nologin:adm:x:
join: /etc/passwd:6: is not sorted: sync:x:5:0:sync:/sbin:/bin/sync <span class="token comment"># 值得注意的是文件要事先按照key排序否则有些信息会被略过</span>
<span class="token number">7</span>:lp:x:4:lp:/var/spool/lpd:/sbin/nologin:lp:x:
join: /etc/group:11: is not sorted: wheel:x:10:wallace
<span class="token number">99</span>:nobody:x:99:Nobody:/:/sbin/nologin:nobody:x:
<span class="token number">65</span>:pegasus:x:66:tog-pegasus OpenPegasus WBEM/CIM services:/var/lib/Pegasus:/sbin/nologin:pegasus:x:
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p><code>paste</code>：和join相比，paste只是简单地将文件每行之间粘贴在一起并用Tab分隔而已。不过join只能处理两个文件，paste可以处理多个文件或stdin，例如：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 将/etc/group读出然后与/etc/passwd /etc/shadow粘贴在一起，最后取出前三行</span>
➜  ~ <span class="token function">cat</span> /etc/group <span class="token operator">|</span> <span class="token function">paste</span> /etc/passwd /etc/shadow - <span class="token operator">|</span> <span class="token function">head</span> -n <span class="token number">3</span> <span class="token comment"># 注意paste最后的“-”，会被当做stdin/stdout</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>expand</code>的作用是将Tab用一定数量的空格替换（默认为8个空格，可以使用-t选项指定空格的个数）</p> <p>五、切割命令<code>split</code>：split命令可以将一份stdin数据分割成多个文件，用法为<code>split [-bl] file PREFIX</code>，-b选项指定单个分割的大小如300k/20m，-l选项指定按行数来切割，PREFIX是分割后文件名的前缀（前缀后会自动加上aa,ab,ac,...这样的后缀）。示例：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 将文件myfile分割为300kb大小的小文件</span>
<span class="token function">split</span> -b 300k ./myfile splitfile
<span class="token comment"># 将这些文件再合成一个文件</span>
<span class="token function">cat</span> splitfile* <span class="token operator">&gt;&gt;</span> myfile
<span class="token comment"># 将ls命令的结果每10行记录成一个文件</span>
<span class="token function">ls</span> -la / <span class="token operator">|</span> <span class="token function">split</span> -l <span class="token number">10</span> - lsroot
`<span class="token variable"><span class="token variable">`</span>

六、参数代换<span class="token variable">`</span></span><span class="token function">xargs</span><span class="token variable"><span class="token variable">`</span>：该命令可以读入stdin的数据并以空格符或者断行字符进行分辨，将数据分割成arguments传递给后面的命令执行。由于很多命令不支持管道命令，xargs可以在该命令和stdin之间架起桥梁。示例：
<span class="token variable">`</span></span>``bash
<span class="token comment"># finger命令可以查询用户帐号的相关说明（可能需要用yum安装一下）</span>
<span class="token comment"># 我们取出/etc/passwd前三行第一列的用户名再作为参数交给finger查询</span>
<span class="token comment"># 先用cut选列还是先用head选行都可以</span>
<span class="token function">head</span> /etc/passwd -n <span class="token number">3</span> <span class="token operator">|</span> <span class="token function">cut</span> -d <span class="token string">':'</span> -f <span class="token number">1</span> <span class="token operator">|</span> <span class="token function">xargs</span> finger
<span class="token function">cut</span> -d <span class="token string">':'</span> -f <span class="token number">1</span> /etc/passwd <span class="token operator">|</span> <span class="token function">head</span> -n <span class="token number">3</span> <span class="token operator">|</span> <span class="token function">xargs</span> finger
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>xargs还可以使用以下选项：</p> <ul><li>-0，将含有的特殊字符还原成一般字符</li> <li>-e'eof'，后接指定的eof（没有空格），分析到该字符串就停止处理</li> <li>-p，处理每个参数都要询问用户</li> <li>-n，后接每次command命令执行时要使用几个参数</li></ul> <h2 id="第12章-正则表达式与文件格式化处理"><a href="#第12章-正则表达式与文件格式化处理" class="header-anchor">#</a> 第12章 正则表达式与文件格式化处理</h2> <p>正则表达式是一种表示方法，可以理解为以行为单位来进行字符串的处理行为，通过一些特殊符号的辅助，可以让用户轻易达到查找、删除、替换某特定字符串的目的。vi、grep、awk、sed等工具支持正则表达式，而cp、ls等命令没有支持正则表达式只能使用bash自身的通配符。</p> <blockquote><p>感觉这部分鸟哥更多是举例子，没有高淇老师讲得系统，所以下面只是列举用法，想要系统学习的话可以看高淇老师的Java300集中对应的那几节。</p></blockquote> <p>首先我们需要了解一些特殊符号（其实是自定义字符集）：</p> <ul><li><code>[:digit:]</code>，代表0~9</li> <li><code>[:alnum:]</code>，26个字母的大小写和数字</li> <li><code>[:alpha:]</code>，26个字母的大小写</li> <li><code>[:lower:]</code>，代表26个小写字母</li> <li><code>[:upper:]</code>，代表26个大写字母</li> <li><code>[:blank:]</code>，空格与Tab键</li> <li><code>[:graph:]</code>，代表除空格和Tab外其他的所有按键</li> <li><code>[:cntrl:]</code>，代表控制按键包括CR、LF、Tab、Del等</li> <li><code>[:print:]</code>，代表任何可以被打印出来的字符</li> <li><code>[:punct:]</code>，代表标点符号，即<code>&quot;'?!;:#$</code></li> <li><code>[:space:]</code>，任何会产生空白的字符例如空格、Tab、CR等</li> <li><code>[:xdigit:]</code>，代表16进制数0~9、a~f、A~F</li></ul> <h3 id="基础正则表达式"><a href="#基础正则表达式" class="header-anchor">#</a> 基础正则表达式</h3> <p>grep可以后接-A（--after-context=NUM）或-B（--before-context=NUM）来指定找到显示关键字所在行的后n行和前n行。下面通过示例来说明如何在grep中使用正则表达式：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 1.查找特定字符串</span>
<span class="token comment"># 在文件regular_express.txt中查找有“the”的行并显示行号</span>
<span class="token function">grep</span> -n <span class="token string">'the'</span> regular_express.txt
<span class="token comment"># 反向查找，即查找没有“the”的行</span>
<span class="token function">grep</span> -nv <span class="token string">'the'</span> regular_express.txt
<span class="token comment"># 查找有“the”的行，不论大小写</span>
<span class="token function">grep</span> -ni <span class="token string">'the'</span> regular_express.txt

<span class="token comment"># 2.用[]来查找字符集</span>
<span class="token comment"># 查找有“test”或taste的行</span>
<span class="token function">grep</span> -n <span class="token string">'t[ae]st'</span> regular_express.txt <span class="token comment"># 其实这样不是很严谨，找的是test或tast</span>
<span class="token comment"># 查找含有“oo”但“oo”之前不是“g”的行</span>
<span class="token comment"># 中括号里第一个字符是“^”表示对该自定义字符集反向选择，不能出现其中的字符</span>
<span class="token function">grep</span> -n <span class="token string">'[^g]oo'</span> regular_express.txt <span class="token comment"># 一行同时出现满足和不满足的也会被找出</span>
<span class="token comment"># 找出包含“oo”前的字符不是小写字符的行</span>
<span class="token function">grep</span> -n <span class="token string">'[^[:lower:]]oo'</span> regular_express.txt
<span class="token function">grep</span> -n <span class="token string">'[^a-z]oo'</span> regular_express.txt

<span class="token comment"># 3.行首与行尾字符^$</span>
<span class="token comment"># 查找行首是小写字符的行</span>
<span class="token function">grep</span> -n <span class="token string">'^[a-z]'</span> regular_express.txt
<span class="token function">grep</span> -n <span class="token string">'^[[:lower:]]'</span> regular_express.txt
<span class="token comment"># 查找行尾是“.”的行</span>
<span class="token function">grep</span> -n <span class="token string">'\.$'</span> regular_express.txt <span class="token comment"># 点号表示任意一个字符，需要转义，如果是CRLF换行符会找不到</span>
<span class="token comment"># 查找空白行</span>
<span class="token function">grep</span> -n <span class="token string">'^$'</span> regular_express.txt

<span class="token comment"># 4.任一字符.和重复字符*</span>
<span class="token comment"># 查找有g和d之间有两个任意字符的行</span>
<span class="token function">grep</span> -n <span class="token string">'g..d'</span> regular_express.txt
<span class="token comment"># 查找含有以“g”和“g”开头和结尾的字符串的行</span>
<span class="token function">grep</span> -n <span class="token string">'g.*g'</span> regular_express.txt

<span class="token comment"># 5.使用量词{}</span>
<span class="token comment"># 查找含有连续两个o的字符串的行</span>
<span class="token function">grep</span> -n <span class="token string">'o\{2\}'</span> regular_express.txt <span class="token comment"># 由于在shell中大括号有特殊意义所以需要转义</span>
<span class="token comment"># 查找以g开头结尾并且中间有且仅由2~5个o的字符串</span>
<span class="token function">grep</span> -n <span class="token string">'go\{2,5\}g'</span> regular_express.txt
<span class="token comment"># 查找以g开头结尾并且中间有且仅由2个以上的o构成字符串</span>
<span class="token function">grep</span> -n <span class="token string">'go\{2,\}g'</span> regular_express.txt
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><p>练习：找出/etc/下文件类型为连接文件的文件名：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 没法用分隔符分割，我数了一下，ls的结果从49个字符开始是文件名</span>
➜  ~ <span class="token function">ls</span> -l /etc <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'^l'</span> <span class="token operator">|</span> <span class="token function">cut</span> -c <span class="token number">49</span>- 
extlinux.conf -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/boot/extlinux/extlinux.conf
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>sed工具</strong></p> <p>sed（stream editor）流编辑器是一个强大的工具，可以用于将数据进行替换、删除、新增选取特定行等功能，可以处理stdin。sed的参数除了选项还有动作，用法为<code>sed [OPTION] 'SCRIPT' [stdin]</code>。常用的选项有：</p> <ul><li>-n，--quiet，--silent，使用安静模式只输出经过处理的行（默认输出所有行）</li> <li>-e SCRIPT，--expression=SCRIPT，在命令行模式上进行sed的动作编辑（没有-e其实也行）</li> <li>-f SCRIPT-FILE，--file=SCRIPT-FILE，执行写入到文件中的动作</li> <li>-r，--regexp-extended，让sed支持扩展正则表达式（默认仅支持基础正则表达式语法）</li> <li>-i SUFFIX，--in-place=SUFFIX，直接修改读取文件的内容而不是由屏幕输出</li></ul> <p>选项后还要接上动作<code>[n1[,n2]] function</code>，n1和n2可选，表示后面的function动作要在那些行之间进行，动作需要用单引号括起来。常用的function有：</p> <ul><li>a，新增，a后接字符串，这些字符串会在当前行的下一行出现</li> <li>i，插入，i后接字符串，这些字符串会在当前行的上一行出现</li> <li>c，替换，c后接字符串，这些字符串会替换n1和n2之间的行</li> <li>d，删除</li> <li>p，打印，将选择的数据打印出来</li> <li>s，替换，格式为s/regexp/replacement/g</li></ul> <p>看理论不好理解，我们看一组示例：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 1. 将/etc/passwd的内容连同行号输出，同时删除2~5行</span>
➜  ~ <span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'2,5d'</span> <span class="token comment"># 只删除第二行'2d' 删除第二行到最后一行'2,$d'</span>
     <span class="token number">1</span>	root:x:0:0:root:/root:/bin/zsh
     <span class="token number">6</span>	sync:x:5:0:sync:/sbin:/bin/sync
     <span class="token number">7</span>	shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown 

<span class="token comment"># 2. 将/etc/passwd的内容连同行号输出，同时在第2~3行每行后追加一行“drink tea”</span>
➜  ~ <span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'2,3a drink tea'</span> <span class="token comment"># 范围参数同上，如果要在每行前插入的话将a改为i即可，如果要插入多行可以用反斜线转义回车</span>
➜  ~ <span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'2,5a drink tea'</span>
     <span class="token number">1</span>	root:x:0:0:root:/root:/bin/zsh
     <span class="token number">2</span>	bin:x:1:1:bin:/bin:/sbin/nologin
drink tea
     <span class="token number">3</span>	daemon:x:2:2:daemon:/sbin:/sbin/nologin
drink tea
     <span class="token number">4</span>	adm:x:3:4:adm:/var/adm:/sbin/nologin
     <span class="token number">5</span>	lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin

<span class="token comment"># 3. 将第2~5行的内容替换为hello world</span>
➜  ~ <span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'2,5c hello world'</span>
     <span class="token number">1</span>	root:x:0:0:root:/root:/bin/zsh
hello world
     <span class="token number">6</span>	sync:x:5:0:sync:/sbin:/bin/sync

<span class="token comment"># 4. 仅列出文件的第5~7行</span>
➜  ~ <span class="token function">sed</span> -n <span class="token string">'5,7p'</span> /etc/passwd <span class="token comment"># 如果不使用-n选项，默认全部输出，并且在5~7行会重复输出一次</span>

<span class="token comment"># 5. 使用正则表达式在行内搜索对应的pattern并予以替换</span>
<span class="token comment"># 例如从ifconfig的输出中找到网卡的IPv4地址所在的行</span>
➜  ~ <span class="token function">ifconfig</span> enp0s3 <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'inet '</span>
        inet <span class="token number">10.0</span>.2.15  netmask <span class="token number">255.255</span>.255.0  broadcast <span class="token number">10.0</span>.2.255
<span class="token comment"># 接下来要使用正则表达式两ip地址前的内容删掉（替换为空字符）</span>
➜  ~ <span class="token function">ifconfig</span> enp0s3 <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'inet '</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/^.*inet //g'</span>
<span class="token number">10.0</span>.2.15  netmask <span class="token number">255.255</span>.255.0  broadcast <span class="token number">10.0</span>.2.255
<span class="token comment"># 再将ip地址后的内容删除</span>
➜  ~ <span class="token function">ifconfig</span> enp0s3 <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'inet '</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/^.*inet // g'</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/ netmask.*$//g'</span>
<span class="token number">10.0</span>.2.15 

<span class="token comment"># 7. 综合练习：查看/etc/man_db.conf的内容中含有“MAN”的行，但不显示批注</span>
<span class="token comment"># 鸟哥给的解法是cat读出-&gt;grep找到有“MAN”的行-&gt;用sed将含有注释的行替换为空行-&gt;用sed删除空行</span>
➜  ~ <span class="token function">cat</span> /etc/man_db.conf <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'MAN'</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/^#.*$//g'</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'/^$/d'</span>
<span class="token comment"># 也可以先用sed将含有注释的行替换为空行，再用grep找到有“MAN”的行</span>
➜  ~ <span class="token function">sed</span> <span class="token string">'s/^#.*$//g'</span> /etc/man_db.conf <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'MAN'</span> 
<span class="token comment"># 其实这个需求直接用grep就能实现了</span>
➜  ~ <span class="token function">grep</span> -v <span class="token string">'#'</span> /etc/man_db.conf <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'MAN'</span>  
MANDATORY_MANPATH			/usr/man
MANDATORY_MANPATH			/usr/share/man
MANDATORY_MANPATH			/usr/local/share/man
（省略）

<span class="token comment"># 8. 用sed直接修改文件内容而非使用stdout</span>
<span class="token comment"># 将regular_express.txt每行结尾的点号替换成感叹号</span>
➜  ~ <span class="token function">sed</span> -i <span class="token string">'s/\.$/\!/g'</span> regular_express.txt  
<span class="token comment"># 在该文件的最后一行追加一行“# This is a test.”</span>
➜  ~ <span class="token function">sed</span> -i <span class="token string">'<span class="token variable">$a</span> # This is a test.'</span> regular_express.txt 
<span class="token comment"># 不打开vim或者gedit编辑器，在一个100万行的文件myFile.csv的第10000行后插入一行“100,120,130”</span>
➜  ~ <span class="token function">sed</span> -i <span class="token string">'10000a 100,120,130'</span> myData.csv
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br></div></div><h3 id="扩展正则表达式"><a href="#扩展正则表达式" class="header-anchor">#</a> 扩展正则表达式</h3> <p>扩展正则表达式能够简化某些场景下基础正则表达式的写法。例如，原来我们要使用grep剔除注释和空行后显示文件内容需要用两次grep：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">grep</span> -v <span class="token string">'^$'</span> file.txt <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token string">'^#'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>使用扩展正则表达式可以简化为：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># grep -E启用扩展正则支持；或直接使用egrep</span>
<span class="token function">grep</span> -vE <span class="token string">'^$|^#'</span> file.txt <span class="token comment"># 扩展正则表达式可以通过|实现分组功能</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>扩展正则表达式的字符有：</p> <ul><li>+，表示前一个字符至少出现1次，至多无数次</li> <li>?，前一个字符出现0次或1次</li> <li>|，用或的逻辑找出多个字符串</li> <li>()，捕获组。后面可以接量词，括号内表示一个整体。括号内也可以使用“或”并将公共的字符放在括号两侧。</li></ul> <h3 id="文件的格式化与相关处理"><a href="#文件的格式化与相关处理" class="header-anchor">#</a> 文件的格式化与相关处理</h3> <p>一、格式化打印printf：后面提到的awk以及c语言中都是利用printf进行。使用的格式为<code>printf '打印格式' 实际内容</code>，一些特殊的格式有：</p> <ul><li>\a，alert，警告声音</li> <li>\b，backspace，退格</li> <li>\f，from feed，清除屏幕</li> <li>\n，new line，输出新的一行</li> <li>\r，return，回车键</li> <li>\t，tab键</li> <li>\v，垂直的tab键</li> <li>\xNN，输出十六进制数NN代表的字符</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 示例：从文本中读出每一行的数据并尝试按照打印格式打印出来</span>
<span class="token comment"># 格式化字符串中的空格也会被打印</span>
➜  ~ <span class="token builtin class-name">printf</span> <span class="token string">'%10s %5i %5i %5i %8.2f <span class="token entity" title="\n">\n</span>'</span> <span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> printf.txt<span class="token variable">`</span></span>                  
<span class="token comment"># 这一行是表格的标题，由于后面都不能被格式化为数值所以显示都是0，可以过滤掉：`cat printf.txt | grep -v 'Name'`</span>
      Name     <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0.00</span>  
    DmTsai    <span class="token number">80</span>    <span class="token number">60</span>    <span class="token number">92</span>    <span class="token number">77.33</span> 
     Vbird    <span class="token number">75</span>    <span class="token number">55</span>    <span class="token number">80</span>    <span class="token number">70.00</span> 
       Ken    <span class="token number">60</span>    <span class="token number">90</span>    <span class="token number">70</span>    <span class="token number">73.33</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>二、awk：好用的数据处理工具</p> <p>awk的格式为：<code>awk '条件类型1{动作1} 条件类型2{动作2} ...' 文件名</code>，awk以一行为一次处理的单位，以字段为最小处理的单位（字段之间以空格或Tab隔开）。awk最常用的动作是通过print的功能将字段数据列出来，我们举个例子：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 使用last查看最近的系统登录记录</span>
➜  ~ last -n <span class="token number">5</span>                
wallace  pts/0        :0               Mon Nov <span class="token number">23</span> <span class="token number">10</span>:22   still logged <span class="token keyword">in</span>   
wallace  :0           :0               Mon Nov <span class="token number">23</span> <span class="token number">10</span>:22   still logged <span class="token keyword">in</span>   
<span class="token function">reboot</span>   system boot  <span class="token number">3.10</span>.0-1160.2.2. Mon Nov <span class="token number">23</span> <span class="token number">10</span>:21 - <span class="token number">16</span>:57  <span class="token punctuation">(</span>06:35<span class="token punctuation">)</span>    
wallace  pts/0        :0               Fri Nov <span class="token number">20</span> <span class="token number">16</span>:02 - <span class="token number">20</span>:31  <span class="token punctuation">(</span>04:28<span class="token punctuation">)</span>    
wallace  :0           :0               Fri Nov <span class="token number">20</span> <span class="token number">16</span>:02 - down   <span class="token punctuation">(</span>04:28<span class="token punctuation">)</span>  
<span class="token comment"># 在前面的基础上取出第一列和第三列</span>
➜  ~ last -n <span class="token number">5</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$1</span> &quot;<span class="token entity" title="\t">\t</span>&quot; <span class="token variable">$3</span>}'</span> <span class="token comment"># awk后的动作是以单引号括住的，里面的格式化字符串用双引号</span>
wallace	:0
wallace	:0
<span class="token function">reboot</span>	boot <span class="token comment"># 能看到由于默认用空格或Tab区分fields，所以这里没有取到预想的部分</span>
wallace	:0
wallace	:0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>awk中也内置了一些<strong>相关的变量</strong>，例如<code>NF</code>（Number of fields，每一行拥有的字段）、<code>NR</code>（Number of input records so far，目前已处理的行数）、<code>FS</code>（Field Separator，字段分隔符，默认是空格），例如显示当前处理到哪一行以及当前行有多少列：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 源数据</span>
➜  ~ last -n <span class="token number">5</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'6,7d'</span>                                                   
wallace  pts/0        :0               Mon Nov <span class="token number">23</span> <span class="token number">10</span>:22   still logged <span class="token keyword">in</span>   
wallace  :0           :0               Mon Nov <span class="token number">23</span> <span class="token number">10</span>:22   still logged <span class="token keyword">in</span>   
<span class="token function">reboot</span>   system boot  <span class="token number">3.10</span>.0-1160.2.2. Mon Nov <span class="token number">23</span> <span class="token number">10</span>:21 - <span class="token number">20</span>:04  <span class="token punctuation">(</span>09:43<span class="token punctuation">)</span>    
wallace  pts/0        :0               Fri Nov <span class="token number">20</span> <span class="token number">16</span>:02 - <span class="token number">20</span>:31  <span class="token punctuation">(</span>04:28<span class="token punctuation">)</span>    
wallace  :0           :0               Fri Nov <span class="token number">20</span> <span class="token number">16</span>:02 - down   <span class="token punctuation">(</span>04:28<span class="token punctuation">)</span>  
<span class="token comment"># 使用awk处理</span>
➜  ~ last -n <span class="token number">5</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'6,7d'</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$1</span> &quot;<span class="token entity" title="\t">\t</span>lines: &quot; NR &quot;<span class="token entity" title="\t">\t</span>columns: &quot; NF}'</span>
wallace	lines: <span class="token number">1</span>	columns: <span class="token number">10</span>
wallace	lines: <span class="token number">2</span>	columns: <span class="token number">10</span>
<span class="token function">reboot</span>	lines: <span class="token number">3</span>	columns: <span class="token number">11</span>
wallace	lines: <span class="token number">4</span>	columns: <span class="token number">10</span>
wallace	lines: <span class="token number">5</span>	columns: <span class="token number">10</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>例子2：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 从/etc/passwd中找出第三个字段代表的uid小于10的用户，并且仅打印还用户的用户名和uid</span>
➜  ~ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'BEGIN {FS=&quot;:&quot;} <span class="token variable">$3</span> &lt; 10 {print <span class="token variable">$1</span> &quot;<span class="token entity" title="\t">\t</span>&quot; <span class="token variable">$3</span>}'</span>
root	<span class="token number">0</span>
bin	<span class="token number">1</span>
daemon	<span class="token number">2</span>
adm	<span class="token number">3</span>
lp	<span class="token number">4</span>
<span class="token function">sync</span>	<span class="token number">5</span>
<span class="token function">shutdown</span>	<span class="token number">6</span>
<span class="token function">halt</span>	<span class="token number">7</span>
mail	<span class="token number">8</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>例子3：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 我们用vim创建这样的一个文件</span>
➜  ~ <span class="token function">cat</span> pay.txt
Name	1st		2nd		3th
Vbird	<span class="token number">23000</span>	<span class="token number">24000</span>	<span class="token number">25000</span>
DMtsai	<span class="token number">21000</span>	<span class="token number">20000</span>	<span class="token number">23000</span>
Wallace	<span class="token number">43000</span>	<span class="token number">42000</span>	<span class="token number">41000</span>
<span class="token comment"># 使用awk处理，如果是第一行就打印相应的标题，如果行数大于等于2就计算第2~4字段的总和并一并打印出来</span>
➜  ~ <span class="token function">cat</span> pay.txt <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'NR==1{printf &quot;%10s %10s %10s %10s %10s<span class="token entity" title="\n">\n</span>&quot;,<span class="token variable">$1</span>,<span class="token variable">$2</span>,<span class="token variable">$3</span>,<span class="token variable">$4</span>,&quot;Total&quot;} NR&gt;=2{total = <span class="token variable">$2</span> + <span class="token variable">$3</span> + <span class="token variable">$4</span>; printf &quot;%10s %10d %10d %10d %10.2f<span class="token entity" title="\n">\n</span>&quot;,<span class="token variable">$1</span>,<span class="token variable">$2</span>,<span class="token variable">$3</span>,<span class="token variable">$4</span>,total}'</span>
<span class="token comment"># 上面的第二个动作中涉及了两个行为：变量赋值和printf，需要用封号隔开，也可以用回车</span>
      Name        1st        2nd        3th      Total
     Vbird      <span class="token number">23000</span>      <span class="token number">24000</span>      <span class="token number">25000</span>   <span class="token number">72000.00</span>
    DMtsai      <span class="token number">21000</span>      <span class="token number">20000</span>      <span class="token number">23000</span>   <span class="token number">64000.00</span>
   Wallace      <span class="token number">43000</span>      <span class="token number">42000</span>      <span class="token number">41000</span>  <span class="token number">126000.00</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>awk的功能非常强大丰富，我们暂时只了解到这里。</p> <p>三、文件比较工具</p> <p><code>diff</code>一般用于ASCII纯文本文件的比较（也可以用于比较两个目录），并且以行为比较单位。用法为<code>diff [-bBi] from-file to-file</code>，两个文件之一可以用<code>-</code>代替来代表stdin，选项有：</p> <ul><li>-b，忽略一行中多个空白的区别，如<code>hello world</code>和<code>hello world</code>视为相同</li> <li>-B，忽略空白行的区别</li> <li>-i，忽略大小写的区别</li></ul> <p><code>cmp</code>一般用于以字节为比较单位去比较两个文件，用法和diff类似，选项有-s用于将所有不同点的字节处都列出来（默认只会输出第一个不同点的位置）。</p> <p><code>patch</code>工具可以将diff工具产生的patch文件作为补丁打到旧文件上去，例如：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 使用diff比较两个文件并制作patch文件</span>
<span class="token function">diff</span> -Naur password.old password.new <span class="token operator">&gt;</span> paswword.patch
<span class="token comment"># 使用patch来更新旧版数据</span>
patch -p0 <span class="token operator">&lt;</span> password.patch <span class="token comment"># -p后面的数字表示要减去几层目录，在整体比较目录时该数字一般大于0</span>
<span class="token comment"># 使用patch来回复旧文件的内容</span>
patch -R -p0 <span class="token operator">&lt;</span> password.patch <span class="token comment"># -R表示恢复文件</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>此外，可以在打印文件前用<code>pr</code>（convert text files for printing）来进行格式预处理，例如加入页面标题等等。</p> <h2 id="第13章-学习shell-script"><a href="#第13章-学习shell-script" class="header-anchor">#</a> 第13章 学习shell script</h2> <p>shell script可以跨平台运行，语法相当亲和，用处很多：</p> <ul><li>帮助系统管理员进行自动化管理，例如查询登陆文件、追踪流量、、监控用户使用主机状态、监控硬件设备状态等。</li> <li>检查对应的shell script可以用于追踪管理系统时出现的问题。</li> <li>可以编写shell script以实现简单的入侵检测功能，并立即通报管理员或者加强防火墙的设置规则。</li> <li>将一连串连续的命令单一化（本博客下的deploy.sh就是这样的一个脚本）。</li> <li>进行简易的数据处理（处理大量数值运算时速度就不如传统的编程语言了）。</li></ul> <p>编写及运行shell script的一些注意事项：</p> <ul><li>脚本是逐行解释执行的，空白行会被忽略，多个空格和Tab都会被视为一个空格，如果读到一个换行则尝试执行该行的命令，可以用<code>\Enter</code>扩展至下一行。</li> <li>使用路径执行脚本：该脚本必须有rx权限，这时可以用绝对路径<code>/absPath/myScript.sh</code>、相对路径<code>./myScript.sh</code>或者将脚本放入$PATH指定的目录下。</li> <li>使用bash命令执行脚本：该脚本只需要r权限即可，通过<code>sh或bash 脚本的绝对或相对路径</code>即可在执行该脚本，这种方式还可以使用bash的一些选项来对脚本进行检查。</li> <li>使用<code>source myScript.sh</code>执行脚本，前面两种方式都是在一个新的bash子进程中执行，执行完毕后子进程的变量不会传回父进程中，而source则是直接在当前bash进程中执行，变量设置等操作会保持有效。</li></ul> <p>我们要养成良好的shell script编写习惯：</p> <ul><li>在每个脚本的头部记录好脚本的功能、版本信息、作者与联络方式、版权声明方式、历史记录</li> <li>脚本内较为特殊的命令使用绝对路径执行</li> <li>脚本执行时需要的环境变量要预先声明并设置</li> <li>最好能想Python中那样用Tab进行缩进排版，增加可读性。</li></ul> <h3 id="简单的shell-script练习"><a href="#简单的shell-script练习" class="header-anchor">#</a> 简单的shell script练习</h3> <p>一、交互式脚本，变量由用户的输入决定。通过<code>read -p</code>实现交互式变量输入。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># Program:</span>
<span class="token comment">#	This program shows full name input by user.</span>
<span class="token comment"># History:</span>
<span class="token comment"># 2020/11/24 Wallace First Release</span>
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span>

<span class="token builtin class-name">read</span> -p <span class="token string">&quot;Please inout your first name:&quot;</span> firstname
<span class="token builtin class-name">read</span> -p <span class="token string">&quot;Please inout your last name:&quot;</span> lastname
<span class="token builtin class-name">echo</span> -e <span class="token string">&quot;Your full name is <span class="token variable">$firstname</span> <span class="token variable">$lastname</span>&quot;</span>
<span class="token builtin class-name">exit</span> <span class="token number">0</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>二、利用日期动态地创建不同文件名的文件。我们常常遇到这样的一种场景：想要自动记录某种特定的日志服务，将每天的内容记录到一个单独的文件中。我们希望文件名有一个统一的前缀用于表示文件内容，同时又希望文件名后面包含该文件对应的日期。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>➜  scripts <span class="token function">cat</span> sh03.sh    
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># Program:</span>
<span class="token comment">#	This program create a series of files with same prefix while distincted by date.</span>
<span class="token comment"># History:</span>
<span class="token comment"># 2020/11/24 Wallace First Release</span>
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span>

<span class="token comment"># 提示用户输入前缀</span>
<span class="token builtin class-name">echo</span> -e <span class="token string">&quot;This program will use 'touch' command to create 3 files.&quot;</span>
<span class="token builtin class-name">read</span> -p <span class="token string">&quot;Please input your file prefix:&quot;</span> file_prefix
<span class="token assign-left variable">filename</span><span class="token operator">=</span><span class="token variable">${file_prefix<span class="token operator">:-</span>&quot;filename&quot;}</span> <span class="token comment"># 分析是否已经设置文件前缀</span>

<span class="token comment"># 获取三个时间并设置到变量中</span>
<span class="token assign-left variable">date1</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> --date<span class="token operator">=</span><span class="token string">'2 days ago'</span> +%Y%m%d<span class="token variable">)</span></span>
<span class="token assign-left variable">date2</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> --date<span class="token operator">=</span><span class="token string">'1 days ago'</span> +%Y%m%d<span class="token variable">)</span></span>
<span class="token assign-left variable">date3</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +%Y%m%d<span class="token variable">)</span></span>
<span class="token comment"># 将前缀和时间变量拼接成新变量</span>
<span class="token assign-left variable">file1</span><span class="token operator">=</span><span class="token variable">${filename}</span><span class="token variable">${date1}</span>
<span class="token assign-left variable">file2</span><span class="token operator">=</span><span class="token variable">${filename}</span><span class="token variable">${date2}</span>
<span class="token assign-left variable">file3</span><span class="token operator">=</span><span class="token variable">${filename}</span><span class="token variable">${date3}</span>

<span class="token comment"># 使用拼接后的文件名创建文件</span>
<span class="token function">touch</span> <span class="token string">&quot;<span class="token variable">$file1</span>&quot;</span>
<span class="token function">touch</span> <span class="token string">&quot;<span class="token variable">$file2</span>&quot;</span>
<span class="token function">touch</span> <span class="token string">&quot;<span class="token variable">$file3</span>&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>三、进行简单的整数四则运算、求余数运算</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>➜  scripts <span class="token function">cat</span> sh04.sh 
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># Program:</span>
<span class="token comment">#	This program does simple integer calculation.</span>
<span class="token comment"># History:</span>
<span class="token comment"># 2020/11/24 Wallace First Release</span>
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span>

<span class="token builtin class-name">read</span> -p <span class="token string">&quot;Input first integer to multiply:&quot;</span> number1
<span class="token builtin class-name">read</span> -p <span class="token string">&quot;Input second integer to multiply:&quot;</span> number2
<span class="token comment"># 这里也可以使用declare -i total=$number1*$number2</span>
<span class="token assign-left variable">result</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>$number1<span class="token operator">*</span>$number2<span class="token variable">))</span></span> <span class="token comment"># 乘号左右的空格可加可不加</span>
<span class="token comment"># 这里后面要直接加句点所以得用花括号区隔，否则花括号可以省略</span>
<span class="token builtin class-name">echo</span> -e <span class="token string">&quot;Result of <span class="token variable">$number1</span> * <span class="token variable">$number2</span> is: <span class="token variable">${result}</span>.&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><code>$((数值运算内容))</code>是一个常用的形式，建议使用这种方式：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>➜  scripts <span class="token builtin class-name">echo</span> <span class="token number">13</span>%3 <span class="token comment"># 默认是作为字符串，加上引号也一样</span>
<span class="token number">13</span>%3
➜  scripts <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">13</span><span class="token operator">%</span><span class="token number">3</span><span class="token variable">))</span></span>
<span class="token number">1</span>
➜  scripts <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span><span class="token number">13</span>%3<span class="token variable">)</span></span>  <span class="token comment"># 13%3本身不是命令所以报错</span>
zsh: <span class="token number">13</span>%3: <span class="token builtin class-name">command</span> not found<span class="token punctuation">..</span>.
zsh: <span class="token builtin class-name">command</span> not found: <span class="token number">13</span>%3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="判断式test和"><a href="#判断式test和" class="header-anchor">#</a> 判断式<code>test</code>和<code>[]</code></h3> <p>前面提到过使用<code>||</code>和<code>&amp;&amp;</code>可以根据前一条命令的回传码来确定后面的命令是否执行。在bash中我们还有很多可用于判断的方法。</p> <p>一、<code>test</code>命令可以用于测试很多条件是否成立，并且不会显示任何结果而是会根据结果返回不同的回传码。该工具可以检查很多东西，包括：</p> <p><strong>测试文件类型</strong></p> <ul><li>-e，该文件名是否存在（exist）</li> <li>-f，该文件名是否存在且为regular file</li> <li>-d，该文件名是否存在且为目录</li> <li>-b，该文件名是否存在且为block device</li> <li>-c，该文件名是否存在且为character device</li> <li>-S，该文件名是否存在且为一个Socket文件</li> <li>-p，该文件名是否存在且为一个pipe（FIFO）文件</li> <li>-L，改文件名是否存在且为一个link file</li></ul> <p><strong>测试文件权限（root权限常常有例外）</strong></p> <ul><li>-r，该文件是否存在并对该文件有可读权限</li> <li>-w，该文件是否存在并对该文件有可写权限</li> <li>-x，该文件是否存在并对该文件有可执行权限</li> <li>-u，该文件是否存在并有SUID属性</li> <li>-g，该文件是否存在并有SGID属性</li> <li>-k，该文件是否存在并有Sticky bit属性</li> <li>-s，该文件是否存在并且非空（size greater than zero）</li></ul> <p><strong>测试比较两个文件的关系 如test file1 -nt file2</strong></p> <ul><li>-nt，一个文件的mtime比另一个文件的mtime更新（newer than）</li> <li>-ot，一个文件的mtime比另一个文件的mtime更旧（older than）</li> <li>-ef，两个文件名是否指向同一个inode。（equal file）</li></ul> <p><strong>测试两个整数之间的关系 如test n1 -eq n2</strong></p> <ul><li>-eq，两数是否相等</li> <li>-ne，两数是否不等</li> <li>-gt，n1是否大于n2</li> <li>-lt，n1是否小于n2</li> <li>-ge，n1是否大于等于n2</li> <li>-le，n1是否小于等于n2</li></ul> <p><strong>测试字符串的属性</strong></p> <ul><li>-z，字符串长度是否为zero（空字符串）</li> <li>-n，字符串是否为非空（空则为false，-n可以省略）</li> <li>str1 = str2，测试两个字符串是否相等</li> <li>str1 != str2，测试两个字符串是否不等</li></ul> <p><strong>多重条件判定</strong></p> <ul><li>-a，（and）如<code>test -r file -a -x file</code>在文件同时可读可执行时回传true。</li> <li>-o，（or）如<code>test -r file -o -x file</code>在文件可读或可执行时回传true。</li> <li>！，（not）如<code>test ! -x file</code>在文件不具有可执行权限时回传true。</li></ul> <p>练习题：让用户输入一个文件名，我们要做到：</p> <ol><li>这个文件是否存在，若不存在则给予一个“Filename does not exist”的讯息，并中断程序；</li> <li>若这个文件存在，则判断他是个文件或目录，结果输出“Filename is regular file”或“Filename is directory”</li> <li>判断一下，执行者的身份对这个文件或目录所拥有的权限，并输出权限数据！</li></ol> <p>我写的shell script如下：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># Program:</span>
<span class="token comment">#	This program use [test] command to print privileges.</span>
<span class="token comment"># History:</span>
<span class="token comment"># 2020/11/25 Wallace First Release</span>
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span>

<span class="token comment"># test file type</span>
<span class="token builtin class-name">read</span> -p <span class="token string">&quot;Input a file path:&quot;</span> targetFile
<span class="token builtin class-name">test</span> -e <span class="token variable">$targetFile</span> <span class="token operator">||</span> <span class="token punctuation">(</span>echo <span class="token string">&quot;<span class="token variable">$targetFile</span> does not exist.&quot;</span><span class="token punctuation">;</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 这边其实有一些逻辑问题</span>
<span class="token builtin class-name">test</span> -f <span class="token variable">$targetFile</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$targetFile</span> is a regular file.&quot;</span>
<span class="token builtin class-name">test</span> -d <span class="token variable">$targetFile</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$targetFile</span> is a directory.&quot;</span>

<span class="token comment"># test privileges</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;Your privileges for the file is:<span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">test</span> -r $targetFile <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">'r'</span><span class="token variable">)</span></span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">test</span> -w $targetFile <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">'w'</span><span class="token variable">)</span></span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">test</span> -x $targetFile <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">'x'</span><span class="token variable">)</span></span>&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>执行脚本的结果如下：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 当前目录下有一个普通文件和目录，当前用户root的权限也如下所示</span>
➜  scripts ll
total 20K
drwxr-xr-x. <span class="token number">2</span> root root   <span class="token number">6</span> Nov <span class="token number">24</span> <span class="token number">17</span>:59 pp
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">626</span> Nov <span class="token number">25</span> <span class="token number">16</span>:13 sh05.sh
➜  scripts <span class="token function">sh</span> sh05.sh
Input a <span class="token function">file</span> path:pp
pp is a directory.
Your privileges <span class="token keyword">for</span> the <span class="token function">file</span> is:rwx
➜  scripts <span class="token function">sh</span> sh05.sh
Input a <span class="token function">file</span> path:./sh05.sh
./sh05.sh is a regular file.
Your privileges <span class="token keyword">for</span> the <span class="token function">file</span> is:rw
➜  scripts <span class="token function">sh</span> sh05.sh
Input a <span class="token function">file</span> path:/dummy
/dummy does not exist. <span class="token comment"># 这之后并没有直接退出</span>
Your privileges <span class="token keyword">for</span> the <span class="token function">file</span> is:
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>可以看到当文件存在时的输出没有问题，不过在文件不存在时出了一些问题，在输出文件不存在后脚本没有执行exit 1结束，这个问题其实之前鸟哥提到过。我原来写的是：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">test</span> -e <span class="token variable">$targetFile</span> <span class="token operator">||</span> <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$targetFile</span> does not exist&quot;</span> <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>该写法在文件存在的时候不会有问题，但是在文件不存在时输出文件不存在后回传码变为1就不会执行exit 1了，应该改写为：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">test</span> <span class="token operator">!</span> -e <span class="token variable">$targetFile</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$targetFile</span> does not exist&quot;</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>另外我的脚本忘记了对用户的输入是否为空（即直接按下回车），如果用户直接按下回车结果也会出现问题，所以应该在用户输入后加入这一行：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">test</span> -z <span class="token variable">$targetFile</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">&quot;You must input a correct file path!&quot;</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>二、使用判断符号<code>[]</code></p> <p>我们可以使用中括号省略<code>test</code>这个命令名，例如要测试$HOME这个变量是否为空，我们可以使用：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">test</span> -z <span class="token environment constant">$HOME</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
<span class="token punctuation">[</span> -z <span class="token string">&quot;<span class="token environment constant">$HOME</span>&quot;</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在使用中括号时，有以下注意点：</p> <ul><li>各元素间务必加上空格</li> <li>中括号内的变量需要用双引号括起来（如果不括起来，且变量中有空格存在时可能会被认为是多个参数）</li> <li>中括号内的常量需要用单引号或双引号括起来</li></ul> <p>练习题，判断用户输入的是<code>y/Y</code>或<code>n/N</code>或是非标准的输入：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># Program:</span>
<span class="token comment">#	This program determins whether user input y/Y/n/N</span>
<span class="token comment"># History:</span>
<span class="token comment"># 2020/11/25 Wallace First Release</span>
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span>

<span class="token builtin class-name">echo</span> -e <span class="token string">&quot;Please input your choice: (y/Y/n/N)&quot;</span>
<span class="token builtin class-name">read</span> choice
<span class="token punctuation">[</span> <span class="token string">&quot;<span class="token variable">$choice</span>&quot;</span> <span class="token operator">==</span> <span class="token string">&quot;y&quot;</span> -o <span class="token string">&quot;<span class="token variable">$choice</span>&quot;</span> <span class="token operator">==</span> <span class="token string">&quot;Y&quot;</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">&quot;Your choice is yes.&quot;</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">exit</span> <span class="token number">0</span>
<span class="token punctuation">[</span> <span class="token string">&quot;<span class="token variable">$choice</span>&quot;</span> <span class="token operator">==</span> <span class="token string">&quot;n&quot;</span> -o <span class="token string">&quot;<span class="token variable">$choice</span>&quot;</span> <span class="token operator">==</span> <span class="token string">&quot;N&quot;</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">&quot;Your choice is no.&quot;</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">exit</span> <span class="token number">0</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;Unrecognized choice&quot;</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>三、shell script的默认变量</p> <p>我们举个例子来说明：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># Program:</span>
<span class="token comment">#	This program uses the parameters of the script</span>
<span class="token comment"># History:</span>
<span class="token comment"># 2020/11/25 Wallace First Release</span>
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span>

<span class="token builtin class-name">echo</span> <span class="token string">&quot;The script name is <span class="token variable">$0</span>&quot;</span> <span class="token comment"># 脚本的文件名</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;Total parameter number is <span class="token variable">$#</span>&quot;</span> <span class="token comment"># 调用脚本时后接参数的个数</span>
<span class="token punctuation">[</span> <span class="token string">&quot;<span class="token variable">$#</span>&quot;</span> -lt <span class="token number">2</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">&quot;Total parameter less than 2, exit.&quot;</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">exit</span> <span class="token number">0</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;Your whole parameter is '<span class="token variable">$@</span>'&quot;</span> <span class="token comment"># 全部参数</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;1st parameter: <span class="token variable">$1</span>&quot;</span> <span class="token comment"># 第一个参数</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;2nd parameter: <span class="token variable">$2</span>&quot;</span> <span class="token comment"># 第二个参数</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>执行结果：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>➜  scripts <span class="token function">sh</span> sh07.sh one two three
The script name is sh07.sh
Total parameter number is <span class="token number">3</span>
Your whole parameter is <span class="token string">'one two three'</span>
1st parameter: one
2nd parameter: two
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>我们可以在脚本中使用<code>shift n</code>来将参数左移n位，左移掉的参数等于“被吃掉了”。</p> <h3 id="使用判断式作为流程控制条件"><a href="#使用判断式作为流程控制条件" class="header-anchor">#</a> 使用判断式作为流程控制条件</h3> <p>一、if语句</p> <p>编程语言中都有最基本的流程控制，shell script也不例外，简单的if-then语句格式为：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token keyword">if</span> <span class="token punctuation">[</span> 判断式 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    COMMANDS
    <span class="token punctuation">..</span>.
<span class="token keyword">fi</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在一个<code>[]</code>判断式中我们可以通过-o或-a放入多个判断条件，也可以使用&amp;&amp;或者||连接多个<code>[]</code>。除了if-then语句，还有else和elif子句。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token keyword">if</span> <span class="token punctuation">[</span> 判断式 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    COMMANDS
<span class="token keyword">elif</span> <span class="token punctuation">[</span> 判断式 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    COMMANDS
<span class="token keyword">else</span>
    COMMANDS
<span class="token keyword">fi</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>二、case语句</p> <p>常规编程语言中我们有switch-case语句，shell script中我们也可以根据变量的不同case选择不同的行为。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token keyword">case</span> $变量名 <span class="token keyword">in</span> 
    <span class="token string">&quot;case1&quot;</span><span class="token punctuation">)</span>
    COMMANDS
    <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token string">&quot;case2&quot;</span><span class="token punctuation">)</span>
    COMMANDS
    <span class="token punctuation">;</span><span class="token punctuation">;</span>
    * <span class="token punctuation">)</span> <span class="token comment"># 相当于其他语言中的default情况</span>
    COMMANDS
    <span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token keyword">esac</span>    
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>例子：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token keyword">case</span> <span class="token variable">$1</span> <span class="token keyword">in</span>
<span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span>
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;Hello there&quot;</span>
	<span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token string">&quot;&quot;</span><span class="token punctuation">)</span>
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;You must input parameters. example &gt; {<span class="token variable">$0</span> someword}&quot;</span>
	<span class="token punctuation">;</span><span class="token punctuation">;</span>
*<span class="token punctuation">)</span>
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;Incorrect params.&quot;</span>
	<span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token keyword">esac</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>三、while循环</p> <p>shell script中的while形式有两种：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 当条件满足时循环执行动作</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> CONDITION <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    COMMANDS
<span class="token keyword">done</span>

<span class="token comment"># 循环执行动作直到条件满足</span>
<span class="token keyword">until</span> <span class="token punctuation">[</span> CONDITION <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    COMMANDS
<span class="token keyword">done</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>练习1：直到用户输入“yes”或“YES”才结束，否则在循环中不断提示用户输入正确的回答</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token string">&quot;<span class="token variable">$user_input</span>&quot;</span> <span class="token operator">!=</span> <span class="token string">&quot;yes&quot;</span> -a <span class="token string">&quot;<span class="token variable">$user_input</span>&quot;</span> <span class="token operator">!=</span> <span class="token string">&quot;YES&quot;</span> <span class="token punctuation">]</span>
<span class="token comment"># until [ &quot;$user_input&quot; == &quot;yes&quot; -o &quot;$user_input&quot; == &quot;YES&quot; ]</span>
<span class="token keyword">do</span>
	<span class="token builtin class-name">read</span> -p <span class="token string">&quot;Please input yes/YES to exit:&quot;</span> user_input
	<span class="token builtin class-name">echo</span> <span class="token variable">$user_input</span>
<span class="token keyword">done</span>	
<span class="token builtin class-name">echo</span> <span class="token string">&quot;You have input the correct answer!&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>练习2：用户输入一个正整数，计算1+2+...+n的结果并输出至屏幕。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">declare</span> -i <span class="token assign-left variable">total</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token builtin class-name">declare</span> -i <span class="token assign-left variable">n</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token builtin class-name">declare</span> -i <span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token builtin class-name">read</span> -p <span class="token string">&quot;Enter the max limit:&quot;</span> n
<span class="token punctuation">[</span> <span class="token variable">$n</span> -lt <span class="token number">1</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">&quot;Not an positive integer!&quot;</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> -le <span class="token variable">$n</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
	<span class="token assign-left variable">total</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span> $total <span class="token operator">+</span> $i <span class="token variable">))</span></span>
	<span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span> $i <span class="token operator">+</span> <span class="token number">1</span> <span class="token variable">))</span></span>
<span class="token keyword">done</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;The result is: <span class="token variable">$total</span>&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>四、for循环</p> <p>shell script中的for循环有两种形式，第一种类似于Python中的循环，或者Java8以后的增强for，需要提供一个变量的取值区间。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token keyword">for</span> <span class="token for-or-select variable">var</span> <span class="token keyword">in</span> con1 con2 con3 <span class="token punctuation">..</span>.
<span class="token keyword">do</span>
    COMMANDS
<span class="token keyword">done</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>后面的condition可以是一连串的字符串，也可以是用cut等命令切出来的一列字符串或是ls列出的一批文件名（只要有空格、Tab、回车分割即可），例如：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 例1，cut切割出所有的账户名</span>
<span class="token assign-left variable">users</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">cut</span> -d <span class="token string">':'</span> -f <span class="token number">1</span> /etc/passwd<span class="token variable">)</span></span> 
<span class="token keyword">for</span> <span class="token for-or-select variable">username</span> <span class="token keyword">in</span> <span class="token variable">$users</span>
<span class="token keyword">do</span>
	<span class="token function">id</span> <span class="token variable">$username</span>
	finger <span class="token variable">$username</span>
<span class="token keyword">done</span>

<span class="token comment"># 例2，ls列出的所有文件名</span>
<span class="token assign-left variable">dir</span><span class="token operator">=</span>/root
<span class="token keyword">for</span> <span class="token for-or-select variable">filename</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">ls</span> $dir<span class="token variable">)</span></span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Full path is <span class="token variable">$dir</span>/<span class="token variable">$filename</span>&quot;</span>
<span class="token keyword">done</span>

<span class="token comment"># 例3，seq生成数字序列</span>
<span class="token assign-left variable">network</span><span class="token operator">=</span><span class="token number">192.168</span>.0
<span class="token keyword">for</span> <span class="token for-or-select variable">host</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> <span class="token number">1</span> <span class="token number">255</span><span class="token variable">)</span></span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;The ip addr is <span class="token variable">${network}</span>.<span class="token variable">${host}</span>&quot;</span>
<span class="token keyword">done</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>第二种for循环的形式只适用于整数变量，类似于Java7前的for循环。这种循环可以很方便的使用数值变量作为计数器，例如：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token assign-left variable">total</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token assign-left variable">limit</span><span class="token operator">=</span><span class="token number">100</span>
<span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>$limit<span class="token punctuation">;</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">))</span></span>
<span class="token keyword">do</span>
    <span class="token assign-left variable">total</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>$total <span class="token operator">+</span> $i<span class="token variable">))</span></span>
<span class="token keyword">done</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;Result of 1+2+...+limit is: <span class="token variable">$total</span>&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>五、用function定义函数</p> <p>由于shell script是脚本语言自上而下执行，所以想要使用函数得在前面先声明：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token keyword">function</span> <span class="token function-name function">myFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;First param of this function is : <span class="token variable">$1</span>&quot;</span> <span class="token comment"># 函数里的$n是调用该函数时后接的参数，而不是脚本的参数。</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>定义完毕后在脚本后面就可以将函数名当作一个普通命令一样去调用，并且可以添加若干参数。</p> <h3 id="shell-script的追踪调试"><a href="#shell-script的追踪调试" class="header-anchor">#</a> shell script的追踪调试</h3> <p>此外，<code>sh</code>命令本身具有一些检查调试相关的选项：</p> <ul><li>-n，不执行该script而是仅仅检查其语法问题。</li> <li>-v，在执行某脚本前，先将脚本内容输出到屏幕上</li> <li>-x，将script每一步的执行过程内容显示到屏幕上</li></ul> <h1 id="第四部分-linux使用者管理"><a href="#第四部分-linux使用者管理" class="header-anchor">#</a> 第四部分 Linux使用者管理</h1> <h2 id="第14章-linux账号管理与acl权限设置"><a href="#第14章-linux账号管理与acl权限设置" class="header-anchor">#</a> 第14章 Linux账号管理与ACL权限设置</h2> <h3 id="linux帐号与用户组"><a href="#linux帐号与用户组" class="header-anchor">#</a> Linux帐号与用户组</h3> <p>在Linux中，<code>/etc/passwd</code>和<code>/etc/group</code>这两个文件记录了UID、GID与帐号名等信息的对应关系，而记录文件、目录权限信息的inode其实记录的是UID、GID，所以该文件中的内容不可随意修改否则可能引起严重的权限问题。</p> <p>/etc/passwd每一行用冒号隔开，一共有七个字段，依次为：</p> <ol><li>账户名</li> <li>密码，为安全现在统一用<code>x</code>代替，现在密码数据改存到/etc/shadow中了</li> <li>UID，特殊的0号表示管理员权限（除了root可以有多个管理员），1~499号保留给系统帐号使用（其中1~99由发行版自动创建，100~499可以给有系统帐号需求的用户使用例如某些高级服务），500~65535是留给一般用户登录用的（我看了CentOS7的/etc/login.defs，系统账号范围是201~999，用户帐号是1000~60000）。</li> <li>GID</li> <li>用户说明信息，例如finger就会读取显示这段信息</li> <li>用户的主工作目录$HOME</li> <li>用户登录后取得的shell（/sbin/nologin是一个特殊的shell，让账户无法取得shell环境）</li></ol> <p>/etc/shadow同样也是以冒号隔开，有9个字段：</p> <ol><li>账户名</li> <li>加密后的密码（只能由密文单向加密得到再比对验证）</li> <li>最近修改密码的日期（距离1970-1-1的天数）</li> <li>密码不可以被修改的天数，0表示可以任意更改</li> <li>密码需要强制更改的天数，超过该天数没有修改则密码过期必须要修改，99999表示没有强制性</li> <li>密码快到期前的警告天数</li> <li>密码过期后的宽限天数，该期间内仍可以用过期密码登录，但登录后会强制修改密码</li> <li>帐号（而非密码）的失效日期，超过该日期无论密码状态如何都不能使用该账号</li> <li>保留字段</li></ol> <p>/etc/group文件每行有4个字段：</p> <ol><li>用户组名称</li> <li>用户组密码，同样是<code>x</code>，很少用到，已经移动到/etc/gshadow中了</li> <li>GID</li> <li>此用户组下所有的账号名称，用逗号分隔</li></ol> <p>/etc/gpasswd文件有4个字段：</p> <ol><li>用户组名称</li> <li>密码列，如果是<code>!</code>表示没有密码，所以没有组管理员</li> <li>该用户组的管理员帐号</li> <li>该用户组下所有帐号的名称</li></ol> <p>一个用户可以加入多个用户组，在/etc/passwd中记录的GID对应的组是<code>“初始用户组”</code>，用户登录到系统后立即拥有该用户组的相关权限。在创建新的文件和目录时就会根据当前的<code>“有效用户组”</code>确定新文件的所属组，可以使用<code>groups</code>命令查看当前用户所属的所有用户组，第一个就是当前有效用户组。进一步可以通过<code>newgrp groupname</code>来切换用户当前的有效用户组（注意该命令实际上会切换到一个新的shell下，环境设置保留但用户组权限会重新计算）。</p> <h3 id="账号管理"><a href="#账号管理" class="header-anchor">#</a> 账号管理</h3> <p>一、新增与删除用户useradd/passwd/usermod/userdel</p> <p>管理员使用useradd来新建一个用户，其格式为<code>useradd [-u UID] [-g 初始用户组] [-G 次要用户组] [-m|M] [-c 账户说明] [-d 指定主目录的绝对路径] [-s shell] 用户名</code>，参数说明：</p> <ul><li>-M，强制不创建主目录（系统账号默认）</li> <li>-m，强制创建主目录（用户帐号默认）</li> <li>-r，创建一个系统帐号，UID会受<code>/etc/login.defs</code>的限制</li> <li>-e，后接一个日期“YYYY-MM-DD”，表示帐号过期的日期</li> <li>-f，指定帐号过期后的宽限天数，0表示不宽限，-1表示禁用过期功能</li></ul> <p>创建新用户时如果没有指定某些参数，那么默认会按照<code>/etc/default/useradd</code>这个文件中的内容来设置，这个文件的内容也可以用<code>useradd -D</code>来查看。创建用户主目录时，会以<code>/etc/skel</code>目录下的内容作为模板（这一点就定义在前者的内容SKEL中）。</p> <p>创建新用户之后由于没有设置密码该账户是无法登录的，需要使用<code>passwd</code>命令来修改密码。所有用户均可以通过该命令修改自身的密码，root可以在命令后加上要修改密码的用户名来修改该用户的密码。常用的选项有：</p> <ul><li>-S，显示/etc/shadow的大多数字段（使用<code>chage -d USERNAME</code>可以看到详细描述）</li> <li>-l，Lock锁定用户不能登录（本质是修改/etc/shadow）</li> <li>-u，unlock解锁</li> <li>-n，（min）后接多少天内不可修改密码</li> <li>-x，（max）后接多少天后必须修改密码</li> <li>-w，（warning）后接过期前的警告天数</li> <li>-i，（inactive）过期后的宽限天数</li> <li>--stdin，使用标准输入流中的数据作为密码，并且无需二次确认</li></ul> <p>一般用户设置密码时会有一些限制如不能和用户名相同、不能过于简单等，这些规则一般受到pam模块管理，不同distribution的/etc/pam.d这个目录下有着对应的内容。</p> <p>创建用户后如果有需要还可以通过<code>usermod</code>来微调用户的部分信息，其大多数选项都和useradd的相同；使用<code>userdel</code>可以删除用户账户（会从上面提到的四个文件中删除对应的行），使用<code>-r</code>选项可以连同该用户的主目录一起删除。</p> <p>二、用户功能</p> <p><code>finger</code>命令可以查看指定用户的信息（指纹）；<code>chfn</code>可以修改用户的指纹信息；<code>chsh</code>的-s选项可以更改当前用户的shell；<code>id</code>可以查看一些uid、gid有关的信息。</p> <p>三、新增与删除用户组</p> <p>同样地，可以使用<code>groupadd</code>、<code>groupmod</code>和<code>groupdel</code>来创建和删除用户组，使用<code>gpasswd</code>可以设置、删除组密码或组管理员、增加组成员。</p> <h3 id="具体权限规划-acl"><a href="#具体权限规划-acl" class="header-anchor">#</a> 具体权限规划：ACL</h3> <p>ACL的全称是Access Control List，可以针对单一用户、单一文件或目录来进行权限设置，但启用ACL需要特定文件系统的支持。ext2、JFS、XFS以上一般都支持。我们通过<code>setfacl</code>和<code>getfacl</code>来设置和查看ACL权限。</p> <p>setfacl的格式为<code>setfacl [-bkRd] [{-m|-x} ACL参数] 文件名</code>常用的选项有：</p> <ul><li>-m，后接要设置的ACL参数</li> <li>-x，后接要删除的ACL参数</li> <li>-b，删除所有的ACL参数</li> <li>-k，删除默认的ACL参数</li> <li>-R，递归设置子目录</li> <li>-d，设置默认ACL参数，只对目录有效</li></ul> <p>示例：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 通常的需求是单独针对某文件设置某用户的权限</span>
setfacl -m u:wallace:rx testFile
<span class="token comment"># 也可以单独针对某文件设置用户组的权限</span>
setfacl -m g:workgroup:rx testFile
<span class="token comment"># 使得设置完之后在目录下新建的文件也能继承ACL权限（使用-R只能递归设置已有的文件）</span>
setfacl -m d:u:wallace:rx /tmp/workFolder
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="用户身份切换"><a href="#用户身份切换" class="header-anchor">#</a> 用户身份切换</h3> <p>通常情况下我们应尽量使用一般身份用户来进行日常作业，只有在需要设置系统环境时才切换到root身份，这样可以尽量避免误操作带来的麻烦；另外有时我们必须要使用系统帐号来执行某些软件，但是以root身份运行权限过高，这时我们可以单独创建一个系统用户来启动软件，如果程序被攻破，系统不至于损坏；还有一些软件本身就不允许用root身份执行，如chrome。</p> <p>一、<code>su</code>，单纯使用su可以切换到root身份，但使用的是non-login shell方式，环境变量仍然是原用户的，使用<code>su -</code>可以以login shell的方式切换到root，<code>su - -c &quot;COMMAND&quot;</code>可以一次性切换到root来执行COMMAND，执行完毕后回到原来的身份。</p> <p>示例：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 一次性切换到wallace的身份并创建某个目录</span>
<span class="token function">su</span> - wallace -c <span class="token string">&quot;mkdir -p /tmp/testdir&quot;</span>
<span class="token function">sudo</span> -u wallace <span class="token function">mkdir</span> -p /tmp/testdir <span class="token comment"># 作用相同</span>
<span class="token comment"># 切换到wallace并一次性执行多个COMMAND</span>
<span class="token function">sudo</span> -u wallace <span class="token function">sh</span> -c <span class="token string">&quot;COMMAND;COMMAND;...&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>二、<code>sudo</code>，为了避免root密码泄露，在/etc/sudoers中配置过的用户可以执行sudo并使用自己的密码来以root权限执行任务，我们可以直接用vim修改该文件或用visudo命令（其实还是调用vi）来修改：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 用户  来源主机=（可切换的身份） 可执行的命令</span>
root	<span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span> 	ALL
<span class="token comment"># 加上百分号表示后面是一个用户组</span>
%wheel	<span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>	ALL
<span class="token comment"># 让用户无需输入自己的密码也可以执行sudo</span>
%wheel	<span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>	NOPASSWD: ALL
<span class="token comment"># 让指定用户可以修改他人密码，但不能修改root密码</span>
wallace <span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>  <span class="token operator">!</span>/usr/bin/passwd, /usr/bin/passwd <span class="token punctuation">[</span>A-Za-z<span class="token punctuation">]</span>*, <span class="token operator">!</span>/usr/bin/passwd root
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>此外可以为多个用户或多个COMMAND设置别名，来统一设置多个用户的权限。</p> <h3 id="linux主机上的用户信息传递"><a href="#linux主机上的用户信息传递" class="header-anchor">#</a> Linux主机上的用户信息传递</h3> <p>一、查询用户已经登录在系统上的用户可以使用<code>w</code>或<code>who</code>，想要知道每个账户最近登录的时间可以使用<code>lastlog</code>，想要知道最近一段时间内的主机登录记录可以使用<code>last</code>命令。</p> <p>二、在使用<code>who</code>后能看到正在使用主机的其他用户及其端口（如pts/1），那么使用<code>write username pts/1</code>就可以输入要发送给他的信息，使用Ctrl+d结束输入后对方就可收到信息。每个用户可以使用<code>mesg n/y</code>来选择关闭或开启消息接收。另外，使用<code>wall &quot;message&quot;</code>可以向全体用户广播信息。</p> <p>三、可以使用<code>mail username@host</code>来给用户写邮件，直接使用<code>mail</code>则是直接进入邮件程序，不过现在该程序使用得非常少了。</p> <hr> <h2 id="第15章-磁盘配额与高级文件系统管理"><a href="#第15章-磁盘配额与高级文件系统管理" class="header-anchor">#</a> 第15章 磁盘配额与高级文件系统管理</h2> <p><strong>暂时略过</strong></p> <hr> <h2 id="第16章-例行性工作"><a href="#第16章-例行性工作" class="header-anchor">#</a> 第16章 例行性工作</h2> <p>Linux下有两种工作调度方式，一种是突发性的（at，需要atd服务），一种是例行性的（crontab，需要crond服务）。</p> <h3 id="仅执行一次的工作调度at"><a href="#仅执行一次的工作调度at" class="header-anchor">#</a> 仅执行一次的工作调度at</h3> <p>/etc/at.deny和/etc/at.allow（更严格，优先级更高，一般只用前者）分别可以存储执行at命令的账户的黑名单和白名单。</p> <p>at的使用格式为<code>at [-mldv] TIME</code>，TIME是指定的时间，按下回车后可以进入at shell输入要执行的多条命令，使用Ctrl+d结束输入；此外还可以使用<code>at -c 1/2/...</code>查看已经规划好的第n个计划任务。</p> <ul><li>-m，（at中执行的stdin/out和终端机环境无关，如果不手动指定输出到终端设备如/dev/tty1的话就会输出到用户的邮箱，计划任务中没有输出则不会发送）使用该选项可以在没有输出信息时仍然发邮件通知用户任务已经完成。</li> <li>-l，列出目前系统上该用户的所有at任务。等同于<code>atq</code>命令。</li> <li>-d，取消一个at中计划的任务。等同于<code>atrm</code>命令。</li> <li>-v，使用较明显的时间格式显示计划任务列表。</li> <li>TIME的格式：
<ol><li>04：00</li> <li>04：00 2020-12-09</li> <li>04：00pm March 17</li> <li>[HH:MM[am|pm]|now] + n [minutes|hours|days|weeks]</li></ol></li></ul> <p>另外，如果执行at命令时的工作目录是working directory，那么时间到之后at执行任务的工作目录也是该目录，和用户是否还在该目录、用户是否通过终端机登录到系统都没有关系。因为系统会将该项at工作独立出当前用户的shell环境中，并交给atd程序来接管。</p> <p>如果想要在CPU负载低的时候（单一时间内负责的工作数量）才执行计划任务可以使用<code>batch TIME</code>来规划，其底层还是调用了at，所以可以用at查看、取消这些任务。</p> <h3 id="周期性工作调度crontab"><a href="#周期性工作调度crontab" class="header-anchor">#</a> 周期性工作调度crontab</h3> <p>cron的名字来自于希腊语chronos，意思是时间。</p> <p>/etc/cron.deny和/etc/cron.allow（更严格，优先级更高，一般只用前者）分别可以存储执行crontab命令的账户的黑名单和白名单。在各用户使用crontab这个命令来新建任务调度后，任务调度会被记录到/var/spool/cron/$USERNAME中（尽量不要直接编辑该文件），并且cron每一项工作的日志都会记录到/var/log/cron中。</p> <p>该命令的语法为<code>crontab [-u username] [-l|-e|-r]</code>，选项为：</p> <ul><li>-u，仅仅root可以使用此选项为其他用户创建计划任务</li> <li>-e，编辑crontab的工作内容</li> <li>-l，查询crontab的工作内容</li> <li>-r，删除所有的crontab工作内容</li></ul> <p>使用-e的话会调用vi编辑上面提到的文件，其实就是cron &quot;tab&quot;le嘛，表格的格式为：</p> <table><thead><tr><th>分</th> <th>时</th> <th>日</th> <th>月</th> <th>周几</th> <th style="text-align:center;">命令串</th></tr></thead> <tbody><tr><td>20</td> <td>12</td> <td>*</td> <td>*</td> <td>*</td> <td style="text-align:center;">mail wallace -s &quot;at 12:00&quot; &lt; /home/wallace/.zshrc</td></tr></tbody></table> <p>上面表格中使用星号表示任意日/月/周只要是12时都执行命令；在同一列中可以用逗号分隔多个满足条件的时间点；可以用减号连接表示一个时间段内所有的整时间点（例如20 8-10表示8:20、9:20、10:20这三个时间点都要执行）；可以用/n表示每n个间隔单位就进行一次（*/5和0-59/5意思相同）。</p> <h3 id="系统的配置文件-etc-crontab"><a href="#系统的配置文件-etc-crontab" class="header-anchor">#</a> 系统的配置文件/etc/crontab</h3> <p>一般用户的例行任务被记录在/var/spool/cron/$USERNAME中，而系统级别的任务则记录在/etc/crontab中，相比前者多了几条记录以及要以什么用户的身份执行：</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token assign-left variable"><span class="token environment constant">SHELL</span></span><span class="token operator">=</span>/bin/bash
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/sbin:/bin:/usr/sbin:/usr/bin
<span class="token assign-left variable">MAILTO</span><span class="token operator">=</span>root

<span class="token comment"># For details see man 4 crontabs</span>

<span class="token comment"># Example of job definition:</span>
<span class="token comment"># .---------------- minute (0 - 59)</span>
<span class="token comment"># |  .------------- hour (0 - 23)</span>
<span class="token comment"># |  |  .---------- day of month (1 - 31)</span>
<span class="token comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span>
<span class="token comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span>
<span class="token comment"># |  |  |  |  |</span>
<span class="token comment"># *  *  *  *  * user-name  command to be executed</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><code>run-parts</code>是一个存放于/bin下的可执行脚本，后接一个目录，作用是运行该目录下所有的脚本。在任务规划时可以使用该命令批量运行写好的脚本。</p> <h3 id="可唤醒停机期间的工作任务"><a href="#可唤醒停机期间的工作任务" class="header-anchor">#</a> 可唤醒停机期间的工作任务</h3> <p>在不是7*24运行的主机环境下，anacron会检测停机期间应该进行但是没有进行的crontab任务，将他们执行一遍，然后anacron就自动停止了。anacron会以一天、一周、一个月为期去检测系统未进行的croontab任务。</p> <p>anacron的运行时间点通常有两个：一是在开机期间运行，二是写入crontab的调度中来在特定时间分析系统未进行的工作。其语法为<code>anacron [-sfn] JOB ...</code>，常用的参数为：</p> <ul><li>-s，start开始连续执行各项工作</li> <li>-f，force强制执行而不会去判断时间记录文件</li> <li>-n，now立刻进行未进行的任务，而不延迟等待时间</li> <li>-u，仅更新时间记录文件的时间戳，不进行任何工作。</li></ul> <h2 id="第17章-程序管理与selinux初探"><a href="#第17章-程序管理与selinux初探" class="header-anchor">#</a> 第17章 程序管理与SELinux初探</h2> <p>程序与进程的概念是老面试基础题了，程序一般是放置在磁盘中，通过用户执行来触发，当触发后加载到内存中就成了进程，进程会拥有使用者的权限（例如/bin/bash），进程衍生出的其他进程（子进程）一般情况下也会沿用父进程的相关权限。</p> <p>在Linux中过程调用通常称为fork-and-exec，父进程先通过fork复制的方式产生一个除了pid和ppid以外都一样的子进程（copy on write的思想，加快创建进程的速度），子进程再以exec的方式执行实际要进行的进程。</p> <p>常驻内存中的进程称为服务（daemon），例如crond、syslogd等。还有一些负责网络联机的服务如apache、named等，它们在被执行后会监听一个网络端口。</p> <p>Linux开机后会提供6个tty终端机进程（tele-typewriter）和1个图形界面，可以使用Ctrl+Alt+F1~F7来切换（不同的distrobution可能有差异）。当出现程序错误导致死机时，可以切换到其它tty进程杀死问题程序就回复正常了。在bash中我们执行命令时也可以在最后加上一个<code>&amp;</code>表示放置与后台执行。</p> <h3 id="bash下的工作管理-job-control"><a href="#bash下的工作管理-job-control" class="header-anchor">#</a> bash下的工作管理 job control</h3> <p>这里工作管理的概念仅涉及每个单独的bash，即管理的是目前shell的子进程，我们无法由tty1的环境去管理tty2的bash及其子进程。几个注意点：</p> <ul><li>bash的job control所触发的进程必须来自于当前shell的子进程</li> <li>你可以控制和执行命令的环境成为前台foregroud</li> <li>后台指的是进程可以自行运行而不需要用户干预（不能等待用户的输入），无法用Ctrl+c来终止。</li></ul> <p>一、将命令直接丢到后台执行：<code>&amp;</code></p> <p>我们可以在shell中输入命令后再加一个<code>&amp;</code>表示要让该进程后台执行，这时bash会给予该命令一个工作号码job number，假设为n，那我们可以通过<code>fg %n</code>来将该命令调到前台。在后台运行的进程的stdout和stderr仍然会输出到前台，有可能干扰到用户当前的工作，所以如果不想看到输出那么可以利用数据流重定向到文件。</p> <p>二、将目前的工作丢到后台中暂停：<code>Ctrl + z</code></p> <p>这里没有太多可说的，再使用<code>jobs</code>可以查看后台工作状态：</p> <ul><li>-l，同时列出pid</li> <li>-r，仅列出running的工作</li> <li>-s，仅列出suspended的工作</li></ul> <p>三、将后台工作拿到前台来处理<code>fg</code></p> <p>直接执行fg会取出jobs的输出中带有+号的任务，即最后一个被放到后台的任务。我们可以使用<code>fg %n</code>取出第n号任务到前台运行，使用<code>fg %-</code>表示会取出jobs的输出中带有-号的任务。</p> <p>四、将后台下的工作状态变为运行：<code>bg</code></p> <p>类似于fg，bg也可以指定任务号来让某个任务在后台变为运行状态。</p> <p>五、🚩管理后台的工作：<code>kill</code></p> <p>kill的用法为<code>kill -signal %jobnumber</code>，kill常用的选项有</p> <ul><li>-l，列出当前kill能使用的信号</li> <li>-1，发送信号1（-SIGHUP），这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止。 此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。</li> <li>-2，发送信号2（-SIGINT），Ctrl+c也是发送了这个信号，表示中断，如何响应中断由程序决定，通常是退出程序。</li> <li>-9，发送信号9（-SIGKILL），强力杀死该进程。</li> <li>-15，发送信号15（-SIGTERM），以常规流程结束进程。</li> <li>-19，发送信号19（-SIGSTOP），相当于用Ctrl+z暂停一个进程执行</li></ul> <p>其实kill的功能不仅限于管理当前shell的jobs，更是可以管理进程process，上面的格式中如果不加%则后面的数字就是进程的pid。</p> <p>六、脱机管理</p> <p>在从当前bash注销后，在后台运行的进程都会被中断掉。想要让注销后任务一直运行有两种方式：</p> <ol><li>使用at将工作托管给atd服务。</li> <li>使用<code>nohup COMMAND &amp;</code>来继续执行COMMAND，不过nohup并不支持bash的内置命令。</li></ol> <h3 id="进程管理"><a href="#进程管理" class="header-anchor">#</a> 进程管理</h3> <p>常见问题：发现系统资源要被使用光，需要找出最耗费系统资源的进程并删除之；或者需要找出运行异常的进程；抑或是想要让某项进程最优先被执行。这些问题都需要我们熟悉进程的管理流程。</p> <p>一、进程的查看</p> <p>进程查看有两种方式，静态的ps（processes snapshot）和动态的top。</p> <p>关于ps，手册比较复杂，鸟哥推荐两个常用的用法：查看当前shell有关的所有进程<code>ps -l</code>和查看所有系统运行的程序<code>ps aux</code>（其实这样记忆不太合适）。</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>➜  ~ <span class="token function">ps</span> -l             
F S   <span class="token environment constant">UID</span>   PID  <span class="token environment constant">PPID</span>  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
<span class="token number">4</span> S     <span class="token number">0</span>  <span class="token number">3709</span>  <span class="token number">3598</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> - <span class="token number">58090</span> do_wai pts/0    00:00:00 <span class="token function">su</span>
<span class="token number">4</span> S     <span class="token number">0</span>  <span class="token number">3718</span>  <span class="token number">3709</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> - <span class="token number">38168</span> sigsus pts/0    00:00:06 <span class="token function">zsh</span>
<span class="token number">0</span> R     <span class="token number">0</span>  <span class="token number">8974</span>  <span class="token number">3718</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> - <span class="token number">38331</span> -      pts/0    00:00:00 <span class="token function">ps</span>
➜  ~ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">head</span> -n <span class="token number">3</span> 
<span class="token environment constant">USER</span>       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         <span class="token number">1</span>  <span class="token number">0.0</span>  <span class="token number">0.3</span> <span class="token number">194172</span>  <span class="token number">7324</span> ?        Ss   <span class="token number">16</span>:08   <span class="token number">0</span>:03 /usr/lib/systemd/systemd --switched-root --system --deserialize <span class="token number">22</span>
root         <span class="token number">2</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S    <span class="token number">16</span>:08   <span class="token number">0</span>:00 <span class="token punctuation">[</span>kthreadd<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>常用的选项有：</p> <ul><li>-A/-e，将所有的进程显示出来而不仅仅是当前terminal有关的进程</li> <li>-a，不与terminal有关的所有进程</li> <li>-u，有效用户的相关进程</li> <li>-f，做一个更完整的输出</li></ul> <p>ps -l是UNIX格式，指的是BSD long format，输出的内容含义为：</p> <ul><li>F，process flag，说明进程权限。4表示有root权限，1表示仅可以fork但不能exec</li> <li>S，stat，说明进程状态。R表示Running，S表示Sleep，D表示不可中断的睡眠状态（如IO阻塞），T表示sTopped，Z表示Zombie僵尸进程。</li> <li>UID/PID/PPID，不解释了。</li> <li>C，CPU使用率百分比。</li> <li>PRI/NI，priority/nice，进程被执行的优先级都是越小则越早被执行</li> <li>ADDR/SZ/WCHAN，与内存地址、占用有关</li> <li>TTY，登录者使用的终端机</li> <li>TIME，实际获得CPU运行的时间</li> <li>CMD，command，程序触发进程的命令</li></ul> <p>ps aux是BSD格式，不带有dash符号（-）实测带了似乎也可以。a表示去掉“only yourself”的限制，x表示去掉“must have a tty”的限制，u表示输出格式为user-oriented format。输出内容的含义为：</p> <ul><li>USER，进程属于哪个用户帐号</li> <li>PID，进程id</li> <li>%CPU，进程使用的CPU百分比</li> <li>%MEM，进程使用的内存百分比</li> <li>VSZ，进程使用的virtual mem size，单位为kb</li> <li>RSS，resident set size，进程使用的非swap内存的内存大小，单位为kb</li> <li>TTY，同上TTY</li> <li>STAT，同上S</li> <li>START，进程被触发启动的时间</li> <li>TIME，同上TIME</li> <li>COMMAND，进程的实际命令</li></ul> <p>僵尸进程指的是进程正常执行完毕或因故终止后，该进程的父进程无法将该进程结束掉，导致该进程一直存在于内存中。</p> <p>如果要找进程之间的相关性，<code>pstree</code>很好用，用法为<code>pstree [-A|-U] [-up]</code>，选项：</p> <ul><li>-A，进程树间用ASCII字符连接</li> <li>-U，进程树间用UTF-8字符连接，某些不兼容的终端下可能出现错误</li> <li>-p，同时列出进程的pid</li> <li>-u，同时列出进程所属帐号的名称。</li></ul> <p>想要动态查看进程的变化可以使用top（或安装htop），使用方式为：<code>top [-d NUMBER]</code>或者<code>top [-bnp]</code>，说明：</p> <ul><li>-d，（delay-time）后接top刷新间隔的秒数，默认为5s</li> <li>-b，以批处理的方式执行top，通常会搭配数据流重定向将批处理的结果输出到文件</li> <li>-n，与-b搭配表示需要几次top输出的结果</li> <li>-p，指定某些PID来进行检测</li> <li>top执行过程中可以使用的按键命令有：
<ul><li>?，显示可用的按键命令</li> <li>P，（大写）以CPU使用率排序显示</li> <li>M，（大写）以内存使用率排序显示</li> <li>m，切换上方的内存显示视图</li> <li>N，以PID来排序</li> <li>T，以已使用的总CPU时间来排序</li> <li>k，给予某个PID一个信号（kill）</li> <li>r，给某个PID重新定制一个nice值（renice）</li> <li>q，退出top</li> <li>1，切换多内核CPU环境下第三行的视图为总体或单个</li></ul></li></ul> <p>二、进程的管理</p> <p>操作系统管理进程就是通过给进程发送一个信号来实现的，这个也是面试长问问题之进程间的通信机制之一。在前面<code>kill</code>那边我们提到过一些信号可以参考。能使用的所有信号可以通过<code>kill -l</code>查看。</p> <p>kill发送信号时需要知道明确的pid，想要通过command name直接发送信号就可以使用<code>killall</code>，格式为<code>killall [-iIe] -SIGNAL [COMMAND NAME]</code>：</p> <ul><li>-i，interactive，交互式确认</li> <li>-I，Ignore-case，忽略名称大小写差异</li> <li>-e，exact，进程名要和后面的命令名（不能超过15个字符）完全一致</li></ul> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># 依次询问每个bash是否需要杀死（包括当前bash，所以必须要交互式确认）</span>
<span class="token function">killall</span> -i -9 <span class="token function">bash</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>三、进程的执行顺序</p> <p>前面提到过PRI与NI，priority是由内核动态调整的用户无法直接调整，用户只能调整nice值，二者的关系为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>PRI(new) = PRI(old) + nice
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>nice可调整的范围是-20~19（root），给予负值PRI减小优先级提高，反之同理。普通用户nice可调整的范围是0~19，并且同一个进程只能越调越高，这是为了避免抢占资源。另外修改了nice后PRI并不一定立刻改变，而是系统分析后才可能修改并且不一定加满nice。</p> <p>可以在执行命令时就在前面通过<code>nice</code>指定nice，也可以通过<code>renice</code>来修改已有进程的nice值</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token function">nice</span> -n NUMBER COMMAND
<span class="token function">renice</span> NUMBER PID
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>四、系统资源的查看</p> <p>使用<code>free [-b|k|m|g]（单位） [-t]（除了mem和swap额外显示total）</code>来查看当前内存用量。</p> <p>使用<code>uname [-a|-srmpi]</code>可以查看内核与系统相关的简要信息。</p> <p>使用<code>uptime</code>可以查看系统开机运行了多久。</p> <p>使用<code>netstat</code>可以用于监控网络相关的进程，选项有：</p> <ul><li>-a，将系统上所有的连接、监听、Socket数据都列出来</li> <li>-t，列出tcp网络数据包的数据</li> <li>-u，列出udp网络数据包的数据</li> <li>-n，不列出进程的服务名称而是以端口号来显示</li> <li>-l，列出目前正在网络监听listen的服务</li> <li>-p，列出进程的PID</li></ul> <p>使用<code>dmesg</code>来分析内核产生的信息。</p> <p>使用<code>vmstat</code>来跟踪监测系统资源的变化。</p> <h3 id="特殊文件与程序"><a href="#特殊文件与程序" class="header-anchor">#</a> 特殊文件与程序</h3> <p>具有SUID权限的可执行文件在运行时取得PID后，其进程的PCB权限设置部分会具有该SUID对应的权限，所以该权限进在运行时才具有。</p> <p>/proc是一个虚拟文件系统，实际上存在于内存中。Linux的哲学是一切皆文件，该目录下每一个PID都有对应的目录，各个进程的相关信息就存放在里面。</p> <p>另外，/proc下一些记录了系统相关信息的文件有：</p> <ul><li>cmdline，加载kernel时所执行的相关参数</li> <li>cpuinfo，本机CPU的相关信息</li> <li>devices，记录了主要设备代号</li> <li>filesystems，目前系统已经加载的文件系统</li> <li>interrupts，目前系统IRQ的分配状态</li> <li>ioports，各设备的IO地址</li> <li>kcore，文件很大，是内存的大小（不要尝试去读该文件）</li> <li>loadavg，uptime top上面的三个平均值5 10 15分钟时的平均负载</li> <li>meminfo，free列出的内存信息</li> <li>modules，内核加载的模块（驱动程序）列表</li> <li>mounts，已经挂载的数据</li> <li>swaps，swap使用的分区</li> <li>partitions，分区信息</li> <li>pci，lspci能查到的pci设备信息</li> <li>uptime，见名知意</li> <li>version，uname -a</li> <li>bus/*，一些总线设备的信息</li></ul> <p>可以通过<code>fuser</code>file user找出正在使用某文件的程序，用法为<code>fuser [-umv] [-k [i] [-SIGNAL]] FILE/DIR</code></p> <ul><li>-u，除了pid外同时列出进程的所有者</li> <li>-m，后接的文件名会主动上提到文件系统的顶层</li> <li>-v，列出文件、程序命令之间的相关性</li> <li>-k，试图向找到的程序发送signal，不写signal的话默认是-9（SIGKILL）</li> <li>-i，与-k配合，发送信号前询问用户意见</li></ul> <p>可以通过<code>lsof</code>list open files打印出被进程所打开的文件名。</p> <p>可以通过<code>pidof PROCESSNAME</code>来根据名称查找进程pid。</p> <h3 id="selinux初探"><a href="#selinux初探" class="header-anchor">#</a> SELinux初探</h3> <p>SELinux的全称是Secure Enhanced Linux，其设计的目标是避免使用者的资源误用，本质上是<strong>进行程序、文件权限设置依据的一个内核模块</strong>。</p> <p>传统的访问文件系统的方式称为<strong>自主访问控制</strong>（DAC，Discretionary Access Control），依据进程的所有者与文件资源的权限设置来确定有无访问的能力，这种情况下如果管理员对某些目录的权限设置不当则可能导致潜在的风险；而SELinux导入了<strong>强制访问控制</strong>（MAC，Mandatory Access Control），以策略规则制定特定程序读取特定文件，可以针对<strong>特定的进程</strong>与<strong>特定的文件资源</strong>来进行权限的控制。</p> <p>一、SELinux的运行模式与相关概念</p> <ul><li>主体Subject：其想要管理的主体就是进程。</li> <li>目标Object：主体进程想要访问的目标资源就是文件系统。</li> <li>策略Policy：SELinux会依据某些服务来制定基本的访问安全性策略，策略内还有详细的规则（rule）来指定不同的服务开放某些资源的访问与否。
<ul><li>targeted：针对网络服务限制较多，针对本机限制较少，是默认策略。</li> <li>strict：完整的SELinux限制，限制方面较为严格。</li></ul></li> <li>安全上下文：除了策略指定之外，主题与目标的安全上下文必须完全一致才能访问。目前我们可以将安全上下文粗略理解为SELinux内的rwx。
<ul><li>安全上下文对于进程来说是存入内存中的，对于文件来说是存入inode中的。</li> <li>在系统启用了SELinux后，可以通过<code>ls -Z</code>来查看文件的安全上下文，通过<code>ps -Z</code>来查看进程的安全上下文。CentOS7中的示例为：“system_u:object_r:admin_home_t:s0”，前三个字段的意义为：
<ul><li>身份标识（identify）：相当于帐号方面的身份标识，包括：
<ul><li>root，表示root的帐号身份</li> <li>system_u，表示系统程序方面的标识</li> <li>user_u，代表一般用户帐号的相关身份</li></ul></li> <li>角色（role）：通过角色字段我们可以知道这个数据是属于程序、文件资源还是代表用户，包括：
<ul><li>object_r，代表文件资源（目标）</li> <li>system_r，代表进程</li></ul></li> <li>类型（type）：最重要的字段，在文件（Object）上的定义为type，在进程（Subject）上的定义为domain。</li></ul></li></ul></li></ul> <p>例子，/usr/sbin/httpd服务与/var/www/html目录：</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>➜  ~ ll -Zd /usr/sbin/httpd /var/www/html
-rwxr-xr-x. root root system_u:object_r:httpd_exec_t:s0 /usr/sbin/httpd
drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www/html
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>首先执行的httpd这个可执行文件具有httpd_exec_t这个类型type，该类型会让这个文件造成的主体进程subject具有httpd_t这个域domain，而系统设置的策略针对这个域已经定制了许多规则，其中包括了这个域可以读取的目标资源类型（包括了httpd_sys_content_t这个类型），那么把网页放置到/var/www/html目录下就能够被httpd这个进程读取了。当然最后能否读到正确的数据还是要看rwx权限是否符合Linux权限规范。</p> <p>二、SELinux的启动关闭与查看</p> <p>目前SELinux支持三种模式，可以使用<code>getenforce</code>命令来查看：</p> <ul><li>enforcing：强制模式，表示SELinux正在运行，并且已经正确开始限制domain/type了</li> <li>permissive：宽容模式，表示正在运行中，不过仅仅是有警告信息而实际不会限制domain/type的访问，一般用于调试</li> <li>disabled：关闭，SELinux并没有运行</li></ul> <p>通过<code>sestatus</code>可以查看SELinux的策略等状态信息，使用-v选项可以检查/etc/sestatus.conf内的安全上下文内容，使用-b选项可以检查目前所有规则的的启动状态。想要启动、关闭或调整SELinux的运行模式与策略，可以修改/etc/selinux/config并重启计算机。另外grub启动菜单中如果配置了selinux=0会无视掉前面的配置而直接略过selinux的加载。（在启用状态下可以通过<code>setenforce 0|1</code>来在enforcing和permissive模式之间切换）</p> <p>三、修改安全上下文</p> <p>鸟哥举的例子是在root的主目录下创建index.html再移动到/var/www/html目录下，这时权限没问题但是由于文件的type是user_home_t而不是httpd_sys_content_t所以在浏览器中无法访问。通过<code>chcon</code>可以修改，格式为<code>chcon [-R] [-t TYPE] [-u USER] [-r ROLE] 文件</code>：</p> <ul><li>-R，递归修改</li> <li>-t，-u，-r，对应type，user，role很好理解了</li> <li>--reference=范例文件，按照范例文件修改</li></ul> <p>另外，某些目录具有默认的安全上下文，可以使用<code>restorecon [-R] FILE/DIR</code>来恢复默认的安全上下文。</p> <p>四、SELinux所需的服务</p> <p>鸟哥提到有名为<code>setroubleshoot</code>的服务用于将错误信息写入/var/log/messages，但是在CentOS7中我使用chkconfig没有找到该服务，理论上该服务记录的信息会给出SELinux拦截的错误信息与对应允许访问的解决方法。</p> <p>另外还有名为auditd的服务将SELinux发生的信息写入/var/log/audit/audit.log，日志内容非常庞大，可以使用<code>audit2why &lt; /var/log/audit/audit.log</code>来读入该文件并分析其中的错误信息。</p> <p>五、SELinux的策略与规则管理</p> <p>策略查阅：CentOS默认使用targeted策略，想要知道该策略提供多少相关规则可以使用<code>seinfo</code>（CentOS7需要安装setools才能使用）来查询：</p> <ul><li>--all，列出SELinux的状态、规则布尔值、身份识别、角色、类型等所有信息（真的非常多）</li> <li>-t，列出所有类型type的种类</li> <li>-r，列出所有角色role的种类</li> <li>-u，列出所有身份标识user的种类</li> <li>-b，列出所有规则bool值的种类</li></ul> <p>我们使用seinfo结合grep找到想要的内容（如httpd）后，可以用<code>sesearch</code>查询细节（我在CentOS7上安装的setools中sesearch的选项已经和鸟哥介绍的不同了）。</p> <p>Subject是否能够访问Object是和bool值有关的，通过seinfo -b可以知道所有的布尔值，那么这些布尔值是启动还是关闭的呢就可以使用<code>getsebool [-a] [bool值]</code>来查看所有或某一项bool值的情况。</p> <p>如果查询到某个bool值，并以sesearch知道该bool值的用途后，可以通过<code>setsebool [-P] [0|1]</code>来关闭或启动该布尔值，-P选项可以将设置值写入配置文件。</p> <p>可以使用<code>semanage</code>来查询、修改各种目录的默认安全上下文（fcontext）。semanage还有更多更强大的功能。</p> <h2 id="第18章-认识系统服务"><a href="#第18章-认识系统服务" class="header-anchor">#</a> 第18章 认识系统服务</h2> <p>在UNIX-Like的操作系统中，deamon指的是守护进程，系统的服务（service）需要特定的deamon来实现。前者偏实现，后者偏逻辑。</p> <h3 id="认识daemon与service"><a href="#认识daemon与service" class="header-anchor">#</a> 认识daemon与service</h3> <p>daemon一般分为两类：</p> <ul><li>stand_alone，可以自行单独启动服务，加载到内存后就一直占用内存等系统资源，相应速度较快。如httpd（WWW服务）和vsftpd（FTP服务）。</li> <li>super daemon，通过一个特殊的daemon（例如xinetd）来管理，没有客户端请求时对应各项服务都是未启动的状态，有请求时super daemon才唤醒对应的服务，请求结束后对应的服务会被关闭。super daemon可以有安全控管的机制，节约系统资源。super daemon也有单线程与多线程两种模式。</li></ul> <p>daemon如果按照提供服务的工作状态来区分，又可以分为signal-control（立即响应请求，如cupsd）和interval-control（定期执行某项工作，如atd和crond）两种。</p> <p>不同服务对应不同的daemon进程，处理网络请求时操作系统通过使用不同的端口号（port）区分不同的服务进程，默认存储在<code>/etc/services</code>这个文件中。</p> <p>一些需要注意的目录：</p> <ul><li>/etc/init.d/，几乎所有的stand_alone类型服务启动脚本都放置在这里，CentOS7是systemd-based OS，绝大部分的启动脚本都被<code>systemctl start/stop XXX.service</code>这样的命令替代。</li> <li>/etc/sysconfig/，几乎所有的服务都会将初始化的一些参数设置写入到这个目录下。例如日志服务syslog的初始化设置就是/etc/sysconfig/syslog，无线网卡的设置是/etc/sysconfig/network-scripts/ifcfg-enp0s3</li> <li>/etc/xinetd.conf和/etc/xinetd.d/，存放了super daemon的配置文件。（我在CentOS7没有看到任何实际文件）</li> <li>/etc，这个目录本身存放了各服务的配置文件</li> <li>/var/lib/，该目录存放了各服务产生的数据库</li> <li>/var/run -&gt; /run，daemon通常会将自己的PID记录一份到该目录中</li></ul> <p>此外还可以通过/usr/sbin/service这个脚本来启动stand_alone的服务脚本，用法为<code>service [SERVICE NAME] (start|stop|restart|...)</code>，在CentOS7中大多数操作会被重定向到systemctl。</p> <h3 id="centos-7-与-systemd"><a href="#centos-7-与-systemd" class="header-anchor">#</a> CentOS 7 与 systemd</h3> <div class="custom-block theorem"><p class="title">CentOS 7注意点</p><p>CentOS 7 使用 systemd 而不是 SysVinit(CentOS 5) 和 Upstart(CentOS 6)作为自身的初始化系统。</p> <div class="custom-block right"><p>查看 <a href="https://blog.51cto.com/13525470/2060765" target="_blank" rel="noopener noreferrer">详情<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></div><p>我手头的这本书是第三版的，仍然是基于CentOS 5的内容。历史上，Linux 的启动一直采用init进程。下面的命令用来启动服务。</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token function">sudo</span> /etc/init.d/apache2 start
<span class="token comment"># 或者</span>
<span class="token function">service</span> apache2 start
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这种方法有两个缺点:一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程；二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</p> <p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。</p> <p><code>systemctl</code>是 Systemd 的主命令，用于管理系统。</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># 重启系统</span>
$ <span class="token function">sudo</span> systemctl <span class="token function">reboot</span>

<span class="token comment"># 关闭系统，切断电源</span>
$ <span class="token function">sudo</span> systemctl poweroff

<span class="token comment"># CPU停止工作</span>
$ <span class="token function">sudo</span> systemctl <span class="token function">halt</span>

<span class="token comment"># 暂停系统</span>
$ <span class="token function">sudo</span> systemctl <span class="token function">suspend</span>

<span class="token comment"># 让系统进入冬眠状态</span>
$ <span class="token function">sudo</span> systemctl hibernate

<span class="token comment"># 让系统进入交互式休眠状态</span>
$ <span class="token function">sudo</span> systemctl hybrid-sleep

<span class="token comment"># 启动进入救援状态（单用户状态）</span>
$ <span class="token function">sudo</span> systemctl rescue
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p><code>systemd-analyze</code>命令用于查看启动耗时。</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># 查看启动耗时</span>
$ systemd-analyze                    
<span class="token comment"># 查看每个服务的启动耗时</span>
$ systemd-analyze blame

<span class="token comment"># 显示瀑布状的启动过程流</span>
$ systemd-analyze critical-chain

<span class="token comment"># 显示指定服务的启动流</span>
$ systemd-analyze critical-chain atd.service
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><code>hostnamectl</code>命令用于查看当前主机的信息。</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># 显示当前主机的信息</span>
$ hostnamectl

<span class="token comment"># 设置主机名。</span>
$ <span class="token function">sudo</span> hostnamectl set-hostname rhel7
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>此外，<code>localectl</code>命令用于查看本地化设置。<code>timedatectl</code>命令用于查看当前时区设置。<code>loginctl</code>命令用于查看当前登录的用户。</p> <p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。Unit 一共分成12种。</p> <ul><li>Service unit：系统服务</li> <li>Target unit：多个 Unit 构成的一个组</li> <li>Device Unit：硬件设备</li> <li>Mount Unit：文件系统的挂载点</li> <li>Automount Unit：自动挂载点</li> <li>Path Unit：文件或路径</li> <li>Scope Unit：不是由 Systemd 启动的外部进程</li> <li>Slice Unit：进程组</li> <li>Snapshot Unit：Systemd 快照，可以切回某个快照</li> <li>Socket Unit：进程间通信的 socket</li> <li>Swap Unit：swap 文件</li> <li>Timer Unit：定时器</li></ul> <p><code>systemctl list-units</code>命令可以查看当前系统的所有 Unit 。<code>systemctl status</code>命令用于查看系统状态和单个 Unit 的状态。</p> <p>对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># 立即启动一个服务</span>
$ <span class="token function">sudo</span> systemctl start apache.service

<span class="token comment"># 立即停止一个服务</span>
$ <span class="token function">sudo</span> systemctl stop apache.service

<span class="token comment"># 重启一个服务</span>
$ <span class="token function">sudo</span> systemctl restart apache.service

<span class="token comment"># 杀死一个服务的所有子进程</span>
$ <span class="token function">sudo</span> systemctl <span class="token function">kill</span> apache.service

<span class="token comment"># 重新加载一个服务的配置文件</span>
$ <span class="token function">sudo</span> systemctl reload apache.service

<span class="token comment"># 重载所有修改过的配置文件</span>
$ <span class="token function">sudo</span> systemctl daemon-reload

<span class="token comment"># 显示某个 Unit 的所有底层参数</span>
$ systemctl show httpd.service

<span class="token comment"># 显示某个 Unit 的指定属性的值</span>
$ systemctl show -p CPUShares httpd.service

<span class="token comment"># 设置某个 Unit 的指定属性</span>
$ <span class="token function">sudo</span> systemctl set-property httpd.service <span class="token assign-left variable">CPUShares</span><span class="token operator">=</span><span class="token number">500</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h2 id="第19章-认识日志文件"><a href="#第19章-认识日志文件" class="header-anchor">#</a> 第19章 认识日志文件</h2> <p>日志文件中通常记录了系统在什么时候由哪个进程做了什么样的行为时，发生了何种事件。日志可以用于帮助解决系统方面的错误或者服务方面的问题，查询过往事件记录。</p> <p>通常系统和第三方服务的日志会存放在<code>/var/log</code>及其对应的子目录下，例如</p> <ul><li>cron，例行性工作调度的执行日志</li> <li>dmesg，开机时内核检测产生的信息</li> <li>lastlog，帐号最近一次登录的相关信息</li> <li>maillog，往来邮件的信息</li> <li>messages，重要，系统发生的错误信息或重要信息（内容很多）</li> <li>secure，涉及到login或者帐号密码的程序的行为会被记录到该文件中</li> <li>wtmp、failog，登录成功与失败的信息（在CentOS7中没有看到failog）</li> <li>httpd/、samba/，特定的服务如httpd会有自己的日志目录</li></ul> <p>日志文件的产生有两种方式，一是软件开发商自定义写入的文件与相关格式，二是通过将信息丢给syslogd(rsyslogd in CentOS 7)这个服务。除了syslogd之外，还需要logrotate进行日志文件的轮替功能。</p> <h3 id="日志文件的内容"><a href="#日志文件的内容" class="header-anchor">#</a> 日志文件的内容</h3> <p>一般来说精油syslog记录的数据会包含：</p> <ul><li>事件发生的日期与时间</li> <li>发生此事件的主机名</li> <li>启动此事件的服务名称（samba、xinetd）或函数名称（libpam）</li> <li>信息的实际数据内容</li></ul> <p>syslog将服务分为auth、cron、deamon、ftp、kern、mail、news、syslog、user等类型。</p> <p>产生的信息会有不同的等级：</p> <ul><li>info，一些基本的信息说明</li> <li>notice，除了info外还需要注意的内容</li> <li>warning，警告信息，可能有问题，但不至于影响到某个daemon运行</li> <li>error，重大的错误导致服务无法运行</li> <li>critical，错误已经到达临界点</li> <li>alert，更严重警告</li> <li>emergency/panic，系统几乎要死机</li></ul> <p>有了类型和等级，就可以在配置文件/etc/syslog.conf（CentOS 5）中细分地设置不同服务类型产生的不同等级的信息要被记录到哪里。</p> <p>另外，日志文件不仅仅可以存储在当前主机的本地磁盘中，还可以指定为打印机、远程主机。可以使用一台单独的主机作为日志服务器来收集管理多台主机的各服务的状态信息，syslog本身就已经具有日志文件服务器的功能了，只是默认没有开启，端口为udp514。</p> <h3 id="日志文件的轮替"><a href="#日志文件的轮替" class="header-anchor">#</a> 日志文件的轮替</h3> <p>syslog是通过daemon的方式来启动的，有记录日志的需求时就会立即执行，而logrotate是通过cron的方式来执行的（也可以手动使用该命令，根据指定的配置文件/etc/logrotate.conf）。</p> <p>在配置文件/etc/logrotate.conf中可以定义在特定时间间隔对日志文件进行轮替，并且可以定义最多留存的文件个数、是否压缩日志文件、日志文件的最大大小等等。</p></div> <footer class="page-edit" style="display:none;"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2021/1/6 21:38:23</span></div></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div class="kanbanniang" data-v-5775ee02><div class="banniang-container" style="display:;" data-v-5775ee02><div class="messageBox" style="right:68px;bottom:190px;display:none;" data-v-5775ee02>
      我是Wallace欢迎你的关注 
    </div> <div class="operation" style="right:90px;bottom:40px;display:none;" data-v-5775ee02><i class="kbnfont kbn-ban-home ban-home" data-v-5775ee02></i> <i class="kbnfont kbn-ban-message message" data-v-5775ee02></i> <i class="kbnfont kbn-ban-close close" data-v-5775ee02></i> <a target="_blank" href="https://vuepress-theme-reco.recoluan.com/views/plugins/kanbanniang.html" data-v-5775ee02><i class="kbnfont kbn-ban-info info" data-v-5775ee02></i></a> <i class="kbnfont kbn-ban-theme skin" style="display:none;" data-v-5775ee02></i></div> <canvas id="banniang" width="150" height="220" class="live2d" style="right:90px;bottom:-20px;opacity:0.9;" data-v-5775ee02></canvas></div> <div class="showBanNiang" style="display:none;" data-v-5775ee02>
    看板娘
  </div></div></div></div>
    <script src="/assets/js/app.c3dada13.js" defer></script><script src="/assets/js/3.113ae115.js" defer></script><script src="/assets/js/1.24f57cb6.js" defer></script><script src="/assets/js/23.25640d0b.js" defer></script>
  </body>
</html>
